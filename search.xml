<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[linux 入门]]></title>
      <url>/2017/12/08/linux/</url>
      <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><pre><code>    1        2    3    4          5             6            7
-rw-r--r--. 1 root root     27034 12月 15 18:40 install.log
    第一项：        权限位
    第二项：  1     引用计数
    第三项：  root  属主
    第四项：  root  属组
    第五项：        大小
    第六项:         最后一次修改时间
    第七项:         文件名
</code></pre><h4 id="提示符：（特殊字符）"><a href="#提示符：（特殊字符）" class="headerlink" title="提示符：（特殊字符）"></a>提示符：（特殊字符）</h4><pre><code>[root@localhost ~]#
当前登录用户@主机名:当前所在目录$

    #       超级用户
    $       普通用户

    当前所在目录：~  用户家目录
    管理员          /root
    普通用户        /home/用户名
</code></pre><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><pre><code>权限位:
    1 234 567 8910
    - rwx rwx ---
    第一位：代表文件类型
            -   普通文件
            d   目录文件
            l   链接文件
    后九位：
            属主权限    u=user
            属组权限    g=group
          其他人权限    o=other

对文件的意义:
    r    读取文件内容 more
    w    编辑 新增 修改文件内容,但是不包含删除文件  vim
    x     可执行

对目录的意义:
    r    可以查询目录下文件名    ls
    w    对目录具有增删改查的权限
    x    可以进入目录

权重:
     r     4    可读
     w     2    可写
     x     1    可执行
</code></pre><h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><h5 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令:"></a>查看命令:</h5><pre><code>ls             显示目录文件
ls -l         长格式显示
ls -a        显示所有文件
ls -all        显示所有文件(长格式)
ls -hl        文件大小显示为常见大小单位 K M G
ls -d        显示目录本身,而不是里面的子文件
ls (路径)

du -sh 文件/目录     查看文件/目录的实际大小

netstat -ntlp    查看所有端口
lsof -i tcp:80     查看80端口占用情况

ps -A            查看全部进程
ps -C 进程名        查看某一条进程
</code></pre><h5 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令:"></a>目录操作命令:</h5><pre><code>切换:
    cd            切换到登录用户家目录
    cd -        切换到上次操作的目录
    cd..        切换到上一级目录
    cd /usr/local/src     (路径)
    相对路径:参照当前所在的目录,进行查找.先确定当前所在目录.
    绝对路径:从根目录开始指定,一级一级递归查找.

linux常见目录:
    /            根目录
    /bin        命令保存目录(普通用户就可以读取的命令)
    /boot        启动目录,启动相关文件
    /dev        设备文件保存目录
    /etc        配置文件保存目录
    /home        普通用户的家目录
    /mnt        系统挂载目录
    /media        挂载目录
    /root        超级用户的家目录
    /tmp        临时目录
    /sbin        命令保存目录(超级用户才能使用的目录)
    /proc        直接写入内存
    /usr        系统软件资源目录
    /var        系统相关文档内容

创建目录:
    mkdir 目录名
    mkdir /root/include/upload/     递归创建目录

删除目录:
    rm -rf 目录名        文件/目录
    rm -r  目录名        删除目录
    rm -f  目录名        强制
</code></pre><h5 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h5><pre><code>创建空文件:
    touch 文件名

查看文件内容:
    cat 文件名

分屏显示文件内容
    more 文件名
</code></pre><h5 id="复制与剪切"><a href="#复制与剪切" class="headerlink" title="复制与剪切"></a>复制与剪切</h5><pre><code>复制粘贴:
    cp     源文件 目标位置
    cp -r     复制目录
    cp -a     所有(包括文件属性一起复制)

    cp 源文件 目标位置 新名字         (改名复制)
剪切:
    mv 源文件 目标位置
改名:
    mv 源文件名 新文件名
</code></pre><h5 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h5><pre><code>chmod  u+x  index.php          属主加上执行权限
chmod  u-x  index.php          属主去除执行权限
chmod  u=rwx index.php        属主添加读写执行权限

chmod  755  index.php        权重表示法
chmod  644  index.php
</code></pre><h5 id="属主和属组命令"><a href="#属主和属组命令" class="headerlink" title="属主和属组命令"></a>属主和属组命令</h5><pre><code>useradd jack    添加用户
passwd    jack    设定用户密码

改变文件属主:
        chown 用户名    文件名    
        chown jack     index.php
同时改变属主和属组:
        chown 用户名:组名     文件名    
        chown jack:jack index.php
</code></pre><h5 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h5><pre><code>man 命令名
man cat
</code></pre><h5 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h5><pre><code>1) 查找命令的命令,同时看到帮助文档的位置
    whereis 命令名

2) 查找文件
    find 查找位置 -name 文件名
    find / -name index.php        按照文件名查找
    find / -iname index.php        不区分大小写

3) 查找字符串
    grep &quot;字符串&quot; 文件名
    grep -v &quot;字符串&quot; 文件名     (反向选择)
    grep -i    &quot;字符串&quot; 文件名    (不区分大小写)
</code></pre><h5 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h5><pre><code>压缩包后缀名:
        .tar.gz        z
        .tar.bz2    j
压缩:
    tar -zcvf 压缩文件/目录 源文件
    tar -zcvf bbs.tar.gz bbs

解压缩:
    tar -zxvf bbs.tar.gz
简写:
    tar -zxf bbs.tar.gz
解压到指定位置:
    tar -zxf bbs.tar.gz -C /tmp/
语义:
    -z: 识别.gz格式
    -c: 压缩
    -v: 显示压缩过程
    -f: 指定压缩包名
    -x: 解压
    -t: 查看不解压

... -C: 指定解压位置
</code></pre><h5 id="关闭和重启"><a href="#关闭和重启" class="headerlink" title="关闭和重启"></a>关闭和重启</h5><pre><code>关机:
    shutdown -h now
重启:
    reboot
</code></pre><h5 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h5><pre><code>linux所有存储设备都必须挂载使用
光盘挂载
    mount    设备描述文件     挂载点(已经存在的空目录)
    mount    /dev/sro    /mnt/cdrom
光盘卸载
    umount    /dev/sro
    umount    /mnt/cdrom    
</code></pre><h5 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h5><pre><code>ifconfig     查看本机网络信息
ifconfig eth0 IP地址     设置临时IP

快捷键:
        CTRL+C 终止命令
        CTRL+A 光标到行首
        CTRL+E 光标到行尾
        CTRL+U 剪切光标前内容
        CTRL+K 剪切光标后内容
        CTRL+Y 粘贴剪切的内容
        CTRL+L 清理屏幕
        CTRL+D 注销登陆相当于exit和logout或者保存
        CTRL+Z 将进程在后台挂起

        |            管道符
        tab            补全功能
        ``          命令替换符  将一个命令的输出作为另一个命令的参数
          ls -l `which touch`     找到touch命令的路径，然后用ls查看属性
</code></pre><h2 id="VIM编辑器-文件操作"><a href="#VIM编辑器-文件操作" class="headerlink" title="VIM编辑器(文件操作)"></a>VIM编辑器(文件操作)</h2><pre><code>文件写入:
    echo &apos;内容&apos; &gt;&gt; 文件名
文件编辑:    
    vi 文件名     编辑该文件

    a    输入
    i    插入
    o    新增下一行

    A    到行的尾部
    I    到行的头部
    O    上一行

    :w    写入
    :wq = :x = ZZ    保存退出
    :q!    不保存退出

命令模式操作:
    hjkl        光标移动
    :n(数字)        移动到第n行
    gg            移动到文件头
    G            移动到文件尾

    x            删除单个字母
    n(数字)+x    删除n个字母
    dd            删除单行 剪切
    ndd            删除多行    剪切
    p            粘贴
    dG            从光标所在行删除到文件尾

    yy            复制单行
    nyy            多行复制

    u            撤销
    Ctrl + r    反撤销

    :set nu        显示行号
    :set nonu    不显示行号

    r+(n)        替换一个字符

    /字串        查找        n下一个 N上一个

    替换:
        :范围/原字串/新字串/g
        ：1,10s/old/new/g         替换1到10行的所有old为new
        ：%s/old/new/g            替换整个文件的old为new
                     g           范围内所有old换为new

        :1,10s/^/#/g            注释
        :6,10s/^#//g            取消注释

        :11,20s/^/\/\//g        注释
        :16,20s/^\/\///g        取消注释
</code></pre><h2 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装</h2><pre><code>软件包分类:
    1) 源码包    .tar.gz     .tar.bz2
    2) 二进制包    .rpm
</code></pre><h4 id="二进制宝安装"><a href="#二进制宝安装" class="headerlink" title="二进制宝安装"></a>二进制宝安装</h4><pre><code>A) rpm手动安装
    1) 光盘挂载
    2) 解决文件依赖关系
    3) 安装tree
    4) 基本命令
        rpm ivh 软件包
        -i 安装     -v 显示详细信息 -h 显示进度

        升级
        rpm -Uvh 软件包

        卸载
        rpm -e 软件包

B) yum命令 二进制包自动化管理
        yum  -y  install  软件包       安装          
        yum  -y  update   软件包       升级
        yum  -y  remove   软件包       卸载
    光盘作为yum源：

        1   cd  /etc/yum.repos.d/
            mv  CentOS-Base.repo  /root/

        2   mount /dev/sr0  /mnt/cdrom

        3   vim  /etc/yum.repos.d/CentOS-Media.repo
            baseurl=file:///mnt/cdrom/  指定yum源位置
            enabled=1                   yum源文件生效

        yum  -y  install  gcc   (gcc是c语言编译器，不装gcc，源码包不能安装)
</code></pre><h4 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h4><pre><code>1   远程传输工具传输apache到linux。
    httpd-2.2.9.tar.gz 
2   安装
    1） 解压
    2） cd  解压目录         
    3） 查看安装文档
        INSTALL     README
    4） 编译前准备
        ./configure  --prefix=/usr/local/apache2
        功能：
            1   检测系统环境，生成Makefile
            2   定义软件选项
    5)  编译              
        make
    6）编译安装
        make  install

    报错判断：
        第一：安装过程是否停止
        第二：注意error  warning  no  等错误报警

3   启动
    /usr/local/apache2/bin/apachectl  start

4   卸载      
    直接删除安装目录
</code></pre>]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS]]></title>
      <url>/2017/12/08/CSS/</url>
      <content type="html"><![CDATA[<h3 id="CSS导入方式"><a href="#CSS导入方式" class="headerlink" title="CSS导入方式;"></a>CSS导入方式;</h3><pre><code>1.外链式:
    在head头标签中,通过link标签 引入css

2.内嵌式:
    在head投标前中,通过style标签当场写css,支队本文件有效

3.内联式(不推荐,优先级太高)
    在开始标签中,通过style属性,给本标签写css

4.导入式:
    在head头标签里,通过style标签,用@import url(CSS文件地址)来富裕CSS
    注意:导入式必须卸载style的最前面

外链式 和 导入式的区别
    1.外链式: 先CSS 再HTML
    2.导入式: 先HTML 再CSS
</code></pre><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色;"></a>颜色;</h3><pre><code>单词
#rrggbb     6位 十六进制 0-9 a-f
#rgb        3位  十六进制
rgb(0~255,0~255,0~255)
rgb(%,%,%)
rgba(0~255,0~255,0~255,0~1) a:透明度 可小数
hsla(0~360,%,%,0~1) 色轮
    H : 色调  0/360红      120绿    240蓝
    S : 饱和度     %
    L : 亮度      %
    A : 透明度     0~1 可小数
透明度:opacity : 0~1
</code></pre><h3 id="绝对长度"><a href="#绝对长度" class="headerlink" title="绝对长度:"></a>绝对长度:</h3><pre><code>px
in  1in = 96px
cm
mm
</code></pre><h3 id="相对长度"><a href="#相对长度" class="headerlink" title="相对长度:"></a>相对长度:</h3><pre><code>%   需要参照物
em  倍数
</code></pre><h3 id="字体"><a href="#字体" class="headerlink" title="字体;"></a>字体;</h3><pre><code>font
font-size:      字体大小
    -family:    字体家族
    -weight:    bold 加粗
    -style:     iitalic 倾斜

line-height: 行高,如果与当前高度一致,可达成垂直居中的效果(仅限一行)

简写:
    font: size  family
    font: [ bold | italic ] size family
    font: [ bold | italic ] size[/line-height] family
</code></pre><h3 id="背景"><a href="#背景" class="headerlink" title="背景;"></a>背景;</h3><pre><code>background
background-color:       背景颜色
          -image:       背景图片 url(&apos;来源地址&apos;)
          -position: x y +:右下 -:左上 背景定位
          -size:        背景大小
          -repeat:no-repeat 背景重复
          -attachment:fixed 背景固定
简写:
    background:[color | image | position[/size] | repeat | attachment]
</code></pre><h3 id="边框"><a href="#边框" class="headerlink" title="边框;"></a>边框;</h3><pre><code>border
border-color:       边框颜色
      -style:       边框风格
      -width:       边框宽度
简写:
    border: color style [width]

单便边框:
    border-方向: 属性简写
          -top
          -left
          -right
          -bottom
圆角:
    border-radius: px %

表格边框合并
    border-collapse: collapse

border = 内边框
outline = 外边框
outline 的语法与border 语法一致
outline:none
</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表;"></a>列表;</h3><pre><code>list-style:none;
</code></pre><h3 id="鼠标样式"><a href="#鼠标样式" class="headerlink" title="鼠标样式:"></a>鼠标样式:</h3><pre><code>cursor:
        pointer     手指
        text        I
        move        十字键
        wait        等待
        none        消失
</code></pre><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标:"></a>字体图标:</h3><pre><code>内嵌式:    @font-face{
            font-family:&apos;字体名&apos;;
            src: url(&apos;ttf文件路劲&apos;);
        }
导入式:
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;字体CSS文件路径&quot;&gt;

调用时,直接就和实体符号一样.
</code></pre><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影;"></a>阴影;</h3><pre><code>box-shadow      盒子阴影
box-shadow: 10px 20px 30px 40px red;
10px:   水平位移
20px:   垂直位移
30px:   模糊度 值越大越模糊,不能为负数.
40px:   阴影面积 可以为负数
</code></pre><h3 id="文本"><a href="#文本" class="headerlink" title="文本;"></a>文本;</h3><pre><code>text
    -indent:                    首行缩进
    -decoration:                文本修饰
                underline       下划线
                overline        上划线
                line-through    删除线
                none            无样式
     -align:                    水平对齐方式  (left,center,right)
    -shadow:                文字阴影
      -overflow: ellipsis     将溢出的隐藏文字用...代替

 vertical-aglin:            垂直对齐方式 (top middle bottom)

    text-shadow: 10px 20px 30px red;
    10px:   水平位移
    20px:   垂直位移
    30px:   模糊度 不能为负数
</code></pre><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出;"></a>溢出;</h3><pre><code>overflow:
            hidden 隐藏溢出内容
            visible 默认，显示溢出内容
            scroll 不管是否溢出都增加滚动条
            auto 根据内容是否溢出，自动增加滚动条
overflow-x: hidden/visible/auto
overflow-y: hidden/visible/auto

min-width   最小宽度
min-height  最小高度
max-width   最大宽度
max-height  最大高度
</code></pre><h3 id="内外边距"><a href="#内外边距" class="headerlink" title="内外边距;"></a>内外边距;</h3><pre><code>外边距:  margin      元素与元素之间的距离

        margin:1px              上下左右
        margin:1px 2px          上下  左右
        margin:1px 2px 3px      上 左右 下
        margin:1px 2px 3px 4px  上 右 下 左

水平居中:
        margin: 0 auto;     没有上下居中

优化水平居中写法:
        margin-left: auto;
        margin-right: auto;

单方向的外边距设置
        margin-方向
              -top
              -left
              -right
              -bottom

内边距:
        padding     边框与内容之间的距离
        padding:1px                 上下左右
        padding:1px 2px             上下 左右
        padding:1px 2px 3px         上 左右 下
        padding:1px 2px 3px 4px     上 右 下 左

注意: 很容易造成视觉上的错觉
</code></pre><h3 id="平滑过渡"><a href="#平滑过渡" class="headerlink" title="平滑过渡;"></a>平滑过渡;</h3><pre><code>transition: p1 p2 p3 p4
        p1: 改变哪个属性  all:所有属性
        p2: 转换时间        单位: s/ms
        p3: 速率
            linear      匀速 默认
            ease        逐渐变慢
            ease-in     加速
            ease-out    减速
            ease-in-out 先加速再减速
        p4: 延迟时间    单位: s/ms

        *一定要有数据的变化过程
</code></pre><h3 id="变形"><a href="#变形" class="headerlink" title="变形;"></a>变形;</h3><pre><code>transform:
        none        不变
        rotate      旋转  单位:deg 角度
        rotateX
        rotateY

        skew        扭曲  单位:deg
        skewX
        skewY

        scale       中心缩放    倍数

        translate   位移
</code></pre><h3 id="行块级"><a href="#行块级" class="headerlink" title="行块级;"></a>行块级;</h3><pre><code>行级元素:   block
    最具代表性: div
        1. 总是独占一行
        2. 宽度默认与浏览器一样宽,与内容无关
        3. 高度默认与内容有关
        4. 内外边距,行高全部可以手动控制
        5. 容纳性:容纳一切元素

行级元素: inline
    最具代表性: span
        1. 总是不独占一行
        2. 宽度默认与内容有关
        3. 高度默认与内容有关
        4. 内外边距,行高只有部分可以控制
        5. 容纳性:只能容纳行级元素
</code></pre><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动;"></a>浮动;</h3><pre><code>float: left | right

清除浮动(自己不能清除自己的浮动,只能清除自己前面的兄弟元素的浮动)

clear: left | right | both

清除方法1:
    在兄弟元素的最后面,加入空元素(块级),
    赋予clear属性,清除前面的兄弟元素浮动

清除方法2: BFC区域
    在父元素赋予以下代码:
    可以清除子元素的浮动
        父元素::before, 父元素::after{
            content:&apos;&apos;;
            display:table;
        }

        父元素::after{
            clear:both;
        }
</code></pre><h3 id="定位"><a href="#定位" class="headerlink" title="定位;"></a>定位;</h3><pre><code>position
绝对定位: absolute
    位置: 不保留原来的位置
    原点: 基于网页第一页的四个角落,不是body体的四个角落

相对定位: relative
    位置: 保留原来的位置
    原点: 基于原来的位置

固定定位: fixed
    位置: 不保留原来的位置
    原点: 基于当前窗口的四个角落
</code></pre><h3 id="元素转换"><a href="#元素转换" class="headerlink" title="元素转换;"></a>元素转换;</h3><pre><code>display:
        none            隐藏(不占位)
        block           转成块级元素
        inline          转成行级元素
        inline-block    转成行块级元素
        table           转成表格
        table-cell      转成普通单元格 td

visibility:
        hidden      占位隐藏
        visible     显示
</code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器;"></a>选择器;</h3><pre><code>1.标签选择器
    标签名{...}  匹配网页中所有指定标签

2.class选择器
    .class名{...}
    注意:多个class名之间用 空格 隔开

3.id选择器
    #id名{...}
    注意:如果id名重复了,后期js会获取不到

4.关联选择器
    s1 : 代表祖辈
    s2 : 代表后辈
    格式:
        s1 s2{...}
        匹配s1下的所有后辈元素s2
        s1 &gt; s2{...}
        只匹配s1下的所有儿子元素s2
        s1 + s2{...}
        只匹配紧跟在s1后的一个兄弟元素s2
        s1 ~ s2{...}
        匹配s1后的所有兄弟元素s2

5.组合选择器
    同时给不同的对象,赋予相同的属性
    s1,s2,s3,...{...}

6.伪对象选择器
    s1::before{ ... }
        匹配s1子元素的最前面
    s1::after{ ... }
        匹配s1子元素的最后面在后期浮动,会有很大的作用

7.伪类选择器
    s1:hover{ ... }
        当鼠标悬停在s1上时,触发CSS
    s1:hover s2{ ... }
        当鼠标悬停在s1上时,s2触发css

    s1:focus{ ... }
        当鼠标获取到光标时,触发CSS

    先看顺序,再看标签
    s1:first-child
        匹配父元素下的第一个子元素s1
    s1:last-child
        匹配父元素下的最后一个子元素s1
    s1:nth-child(num)
        匹配父元素下的第NUM个子元素s1

    先看标签,再看顺序
    s1:first-of-type
        匹配父元素下的子元素s1中第一个
    s1:last-of-type
        匹配父元素下的子元素s1中最后一个
    s1:nth-of-type(num)
        匹配父元素下的子元素s1中第NUM个
</code></pre><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级;"></a>优先级;</h3><pre><code>1.权重值:
    标签: 1
    class: 10
    id: 100
    最高权重: !important
    权重值可以叠加

2.默认优先级: 谁离标签越近,谁的优先级就越高

3.继承性:
    大部分的后辈元素都可以继承祖辈元素的属性少部分不能继承
    例如:
        a标签的颜色
        h标签的大小和颜色
4.总结:在权重相同的情况下,比谁的优先级更高.
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript课程]]></title>
      <url>/2017/12/08/JAVASCRIPT/</url>
      <content type="html"><![CDATA[<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><pre><code>1.写在header中的script标签内.
2.外部文件导入,script标签导入&lt;script src=&quot;script.Js&quot;&gt;&lt;/script&gt;
3.通过事件写在标签内&lt;tag onclick=&quot;code....&quot;&gt;&lt;/tag&gt;
</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre><code>1.JS中一切都区分大小写
2.不能以数字开头,可以由数字/字母/下划线/$组成.
3.注释:
        单行://
        多行:/**/
4.结束语句:
        ; 或换行 (推荐全部用分号结尾)
5.关键字和保留字
    break       else        new     var
    case        finally     return  void
    catch       for         switch  while
    abstract    enum        int     short
    ······    
6.单引号 双引号 反引号 功能一样,都可以解析转移字符,但不解析变量;
</code></pre><h2 id="变量的声明方式"><a href="#变量的声明方式" class="headerlink" title="变量的声明方式:"></a>变量的声明方式:</h2><pre><code>1.var 变量名 = &apos;值&apos;;
2.var 变量名 = &apos;值&apos;,    变量名 = &apos;值&apos;,变量名 = &apos;值&apos;;        
3.var 变量名1 = 变量名2 = 值;
</code></pre><h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型:"></a>变量的类型:</h2><pre><code>typeof();     返回一个值或变量的数据类型;

一.基本类型
    string         字符串
    boolean        布尔值
    Number         数值
二.复合类型
    Obejct         对象
    Array         数组
三.特殊类型
    Null         空
    undefined     未定义
    function     函数
</code></pre><h3 id="数值类型扩展"><a href="#数值类型扩展" class="headerlink" title="数值类型扩展"></a>数值类型扩展</h3><pre><code>一.整数型        (十进制 十六进制 八进制 二进制)

二.浮点型        1) 科学计数法(浮点数精度问题:系统无法准确给出0.3的数值)
               2) 数值范围 5e324 ~ 1.7976931348623157e+308 超过范围回自动转换成 infinity(正无穷) -infinity(负无穷)
               3) 小数点和对象调用符都是. 小数点优先级大于调用符;


三.NaN类型 (Not a Number)
    1 NaN与任何数字操作,结果都是NaN.
    2 NaN与任何值都不相等,包括NaN本身.
    3 函数isNaN()判断是否是NaN?

四.Number()类型转换
    1.布尔值 true = 1; false = 0;
    2.数字不变
    3.null = 0;
    4.undefined = NaN
    5.字符串:
            1) &quot;011&quot; = 11;
            2) &quot;1.1&quot; = 1.1;
            3) &quot;0xff&quot; = 255;  解析进制数
            4) &quot; &quot; = 0;
            5) &quot;12e2&quot; = 1200; 科学计数法
            6) 其他都为NaN

五.ParseInt()类型转换
    1. 数字开头的字符串,忽略后面的字母.
    2. 0x开头会转换成十六进制,0不可以.
    3. 解析科学计数法,字母为0.
    4. 空字符串NaN
    5. null true false = NaN
    6. 
六.ParseFloat()类型转换
    1.第一个小数点有效,后面都无效
    2.数字开头的字符串,忽略后面的字母
    3.科学计数法有效
    4.解析进制数,不解析字符串进制数
</code></pre><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><pre><code>1.数字类型:在字符串环境下隐式转换成字符串.
2.字符串类型:在数字环境下,可以隐式转换为字符串中的数字或NaN;
            在布尔环境下,可以转换为true或false;
3.空字符串:数字环境为0,布尔为false;
          &quot;true&quot; 数字为1,布尔为true;
          &quot;false&quot; 数字为0,布尔为false;
4.null: 字符串为null,数字为0,布尔为false;
5.NaN: 字符串为NaN,布尔为false;
6.undefined:字符串为undefined,数字为NaN,布尔为false;
</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>一.声明及使用方式:
        1) 关键字方式;
           function 函数名(){

           }

        2)表达式方式;
          var 函数名 = function(){

          }

        3)构造函数方式
          var 函数名 = new Function(&quot;参数&quot;, &quot;函数体&quot;);

    使用函数:
            函数名();    调用函数:返回的是函数运算的结果,也就是return的结果.
            函数名;        引用函数:相当于把整个函数复制过来.

    特点:可以重复定义,像变量一样;

二.函数中的参数
    实参个数 &gt; 形参个数;         多余实参无效;
     形参个数 &gt; 实参个数;        多余形参返回undefined

    *注意事项:
        1.如果没有实参,那就用形参默认值.形参没有默认值,则返回undefined;
        2.JS形参的默认值,只能在函数内部通过声明变量的方式实现;
        例子:
            function text(m){
                var m = 123;
            }

    可变参数个数的函数: arguments     获取到一个数组,内含有传递的参数;
</code></pre><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><pre><code>1.在函数内使用var 定义的是 局部变量
2.在函数外使用var 定义的是 全局变量
3.在函数内不使用var 定义的是 全局变量

*JS函数运算时,如果在当前作用域里未找到某一个变量.则会向上一级作用域去找,一直到全局环境,如果全局中也没有该变量,则函数执行时会报错.

自执行函数:
1. (function(){})();
2. (function(){}());
简单理解:将一个匿名函数当成函数名,直接引用.
</code></pre><h2 id="对象-Ps-JS中一切皆为对象"><a href="#对象-Ps-JS中一切皆为对象" class="headerlink" title="对象 (Ps:JS中一切皆为对象)"></a>对象 (Ps:JS中一切皆为对象)</h2><pre><code>一.创建对象
1) Object构造函数方式:
    var 对象名 = new Object();
    对象名.属性名 = &quot;值&quot;;
    对象名.方法名 = function(){
        方法体
    }

2) JSON方式:
    var 对象名 ={
        &quot;属性名&quot; = &quot;值&quot;;
        方法名:function(){
            方法体
        }
    }

3) 自定义构造函数:
    function 函数名(){
        this.属性名 = &quot;值&quot;;
        this.方法名 = function(){
            方法体
        }    
    }
    var 对象名 = new 函数名();

4) 匿名构造函数
    var 对象名 = new function(){
        this.属性名 = &quot;值&quot;;
        this.方法名 = function(){
            方法体
        }
    }

二.使用对象成员:
    对象名.属性名;        (只能打印查看或删除)
    对象名.方法名();

三.删除对象成员:
    delete 对象名.属性名;
    delete 对象名.方法名;    (注意:只能是引用)
</code></pre><h3 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h3><pre><code>constructor
查找对象的归属,用Object和JSON方式的都是来自于系统内置对象.其他方式都能得到对应的对象名.
</code></pre><h3 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h3><pre><code>用于给一个构造函数(类)添加新方法.
1. 模拟对象的继承性
2. 给系统内置对象 添加新方法
例如:
    function User(){
        this.name = &apos;沙沙&apos;;
        this.age = &apos;16&apos;;
        this.getInfo = function(){
            document.write(&apos;HI&lt;br&gt;&apos;);
        }
    }

    User.prototype.getMsg = function (){
        document.write(&apos;Hi~ o(*￣▽￣*)ブ&lt;br&gt;&apos;);
    }

    var o1 = new User();
    var o2 = new User();

    o1.getMsg();
    o2.getMsg();
</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>一.声明方式:
    1) var 数组名 = new Array();     带一个参数表明键的步长,多个参数则视为初始赋值.
    2) JSON方式 (推荐)
        var 数组名 = [];         带参数等于初始值.
多维数组的创建方法:
    数组名[0] = new Array();

二.特点:
    1. JS里只有索引数组,飞数字下标的视为该对象的属性.
    2. 下标值为空,返回undefined.
    3. 不能不使用[],追加可以用push()

三.数组遍历:
    数组形式(索引)    用for 遍历
    对象形式(关联)    用for in 遍历
原因:
    for 遍历对象形式时,没有长度可以参照.
    for in 遍历数组时,会把length当成属性遍历出来.
</code></pre><h2 id="this的简单介绍"><a href="#this的简单介绍" class="headerlink" title="this的简单介绍"></a>this的简单介绍</h2><pre><code>1.循环绑定事件时,获取触发事件的元素,需要使用this
2.元素内部绑定事件时,传入this来表示该元素对象自己

this一般代表最终调用对象.
</code></pre><h2 id="闭包简单介绍"><a href="#闭包简单介绍" class="headerlink" title="闭包简单介绍"></a>闭包简单介绍</h2><pre><code>1. 函数内部的函数.作用是在全局想要获取函数内部的属性或变量时,可以用闭包函数来实现过.
2. 常用在循环绑定事件时,将循环变量保留下下来,就必须使用闭包.
    闭包的结构:
            for (var i = 0; ....) {
                (funciton(i){
                    element.event = function (){
                        // 使用 i,x,y....
                    }
                })(i);
            }
</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code>一.事件的绑定
    1) &lt;button 事件=&quot;Jscode&quot;&gt;&lt;/button&gt;

    2) 元素名.事件 = function(){
            方法体
       }

    3) function 函数名(){
               函数体
       }
       元素名.事件 = 函数名;     (注意:是引用方式)

    4) 事件监听:
        非IE) 元素名.addEventListener(&apos;事件的名字&apos;, 函数或引用, false);
        IE) 元素名.attachEvent(&apos;事件的名字&apos;, 函数或引用);

        function 函数名(){
               函数体
       }

二.解除绑定
    对应绑定方法1-3:
            1. 元素名.事件 = function (){}
            2. 元素名.事件 = null;
    监听方式:
            非IE: removeEventListener(&apos;事件名字&apos;, 函数或引用, false);
            IE  : detachEvent(&apos;事件名字&apos;,函数或引用);
</code></pre><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><pre><code>onclick        单击
ondblclick     双击
oncontextmenu  右击
onmouseover    鼠标移入
onmouseout     鼠标移出
onmousedown    鼠标按住
onmouseup      鼠标松开
onmousemove    鼠标移动
</code></pre><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><pre><code>onkeydown    按下按键触发
onkeyup      松开按键触发
onkeypress   按下并松开时触发(高级事件) (非输出按键不能触发)
</code></pre><h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><pre><code>onsubmit   表单被提交时触发  (需要return false;)
onreset    表单被重置时触发
onfocus    获取焦点时触发
onblur     失去焦点时触发
onselect   选中时表单控件就触发
oninput    非IE: 输入时触发
onpropertychange    IE: 输入时触发 (IE 9.0-)
onchange   改变表单控件的内容或状态时 就触发 (用于input元素时,value值变化且失焦才会触发)
</code></pre><h3 id="框架-对象事件"><a href="#框架-对象事件" class="headerlink" title="框架/对象事件"></a>框架/对象事件</h3><pre><code>onload        文档或图片加载完触发; 文档需要用window调用
onunload     文档关闭时触发(IE)
onbeforeunload    文档关闭时触发(非IE)(浏览器阻止了关闭前的弹框 需要return &quot;string...&quot;)
onabort     图片加载过程中中断触发
onerror     图片加载错误触发
onresize     窗口/框架大小变化时触发
onscroll    元素滚动条在滚动式触发
</code></pre><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><pre><code>oncopy         拷贝内容时触发
oncut         剪切内容时触发
onpaste        粘贴内容时触发
onplay        音/视频开始播放时触发
onpause     音/视频暂停时触发
onended        音/视频播放结束时触发
</code></pre><h2 id="Event事件对象"><a href="#Event事件对象" class="headerlink" title="Event事件对象"></a>Event事件对象</h2><pre><code>Event对象:
    代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。
1.获取
元素.事件 = function(e){
    var e = en || window.event;
}
2.属性
    e.clientX  鼠标x坐标
    e.clientY  鼠标y坐标
    e.keyCode  按键码
</code></pre><h2 id="常用HTML元素属性"><a href="#常用HTML元素属性" class="headerlink" title="常用HTML元素属性"></a>常用HTML元素属性</h2><pre><code>1) innerHTML   元素内部的内容(不含标签本身)
   innerText   元素内部的文本
   outerHTML   元素内部的内容(含标签本身)

2) className   当前元素的class属性值
   tagName       当前元素的标签名

3) scrollLeft  scrollTop 滚动条至左/上边距的像素
4) offsetLeft  offsetTop 距离已定位的父元素的 左/上偏移量

5) offsetWidth / offsetHeight
        盒子模型的宽高:   内容 + 内边距 + 边框
6) clientWidth / clientHeight
        内容 + 内边距
7) scrollWidth / scrollHeight
        宽高 + 内边距+ 计算内部元素的大小
8) document.documentElement.clientHeight  视口高度

9) document.documentElement.scrollHeight  文档高度

待补充....
</code></pre><h2 id="BOM-浏览器模型对象"><a href="#BOM-浏览器模型对象" class="headerlink" title="BOM 浏览器模型对象"></a>BOM 浏览器模型对象</h2><pre><code>对象种类:
        自定义对象
        内置对象 A S N B R M D G
        BOM
        DOM

对象树:(倒树状结构)
                    window
                      |
history   location document  screen   navigator
                        |
                &lt;!---&gt;    html
                            |
                    body   head
                      |
                div p span h1 video
BOM 对象:
    一. window 
        1) 概念:
                描述整个浏览器窗口
                它是JS中 所有对象的根对象
                使用window的属性或方法时,可以省略window去调用
                自定义对象/变量/ 函数  都属于window
        2) 属性: 见手册
        3) 方法:
                setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。
                setTimeout() 在指定的毫秒数后调用函数或计算表达式。
                clearInterval() 取消由 setInterval() 设置的 timeout。
                clearTimeout() 取消由 setTimeout() 方法设置的 timeout。

                alert()    警告框
                confirm()  确认框
                prompt()   输入框

                open()    打开新窗口
                close()   关闭自己打开过的窗口
                print()   打印

                scrollTo()   滚到哪去
                scrollBy()   滚多少
    二. history
        1) 方法:
                history.back()        上一步
                history.forward()    下一步
                history.go()        上/下 N步 负数为上 正数为下
    三. location
                 window.location    查看返回的对象
            属性:
               location.href        URL 地址
                        host        主机名和端口号
                        hostname    主机名
                        protocol    协议
                        pathname    路径
                        search        get参数部分
                        hash        锚点参数
            方法:
                location.reload()  重载页面
                         assign(&apos;网址&apos;)  加载新的页面
                         replace(&apos;网址&apos;) 替换当前页面
                location.href =    &apos;网址&apos;    跳转
</code></pre><h2 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM 文档对象模型"></a>DOM 文档对象模型</h2><pre><code>1. DOM基本介绍
    DOM 是 Document Object Model 文档对象模型
    1. HTML DOM
    2. XML DOM
2. HTML DOM 对象参考
    2.1 document 对象
         1) 属性
                document.domain        域名
                         lastModified  文档最后一次修改时间
                         referrer      上一个页面地址
                         URL           URL
                         title        文档标题
                         cookie       cookie
        COOKIE的操作方法:
            读取
            document.write(document.cookie);
            设置
            document.cookie = &quot;sex=&apos;女&apos;&quot;;
            修改
            document.cookie = &quot;username=&apos;yanyan&apos;; path=/&quot;;
            var d = new Date();
            d.setTime(d.getTime() +3600*1000);
            document.cookie = &quot;username=&apos;yanyan&apos;; path=/; expires=&quot;+d.toUTCString();

         2) 方法
                document.write()
                document.getElement.....等各种获取元素对象
    2.2 form 对象
    2.3 image 对象
    2.4 anchor 对象
    2.5 base 对象
    2.6 canvas 对象
    2.7 Event 对象
    2.8 input 系列对象
        blur()        
        focus()
        select()
    2.9 select 对象
    2.10 option 对象
    2.11 style 对象
    2.11 table 对象
            方法:
                insertRow()     添加行 参数为 添加到第几行
                deleteRow()        删除行 参数为 删除第几行
    2.12 tableRow 对象
            方法:
                deleteCell() 删除行中的指定的单元格。 
                insertCell() 在一行中的指定位置插入一个空的 &lt;td&gt; 元素。 
    2.13 tableCell 对象
            属性:见手册;
</code></pre><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><h3 id="1-节点介绍"><a href="#1-节点介绍" class="headerlink" title="1.节点介绍"></a>1.节点介绍</h3><pre><code>1.1 什么是节点 node
    HTML中所有的组成部分

    document  文档
    element   元素  HTMLdom
    attr      属性  Attribute
    text      文本
    comment   注释

1.2 节点树
    子节点
    父节点
    同辈节点
    后代节点
    先辈节点

1.3 节点的访问(对象选择器)
    获取节点
        document: 直接使用document
        element(元素标签): getElementById...
        attr(属性): element.getAttributeNode()
        text: 子节点
        comment: 子节点

    获取子节点
        childNodes
    获取子元素节点
        children
    获取第一个子节点
        firstChild
    获取最后一个子节点
        lastChild
    获取父节点
        parentNode
    获取父元素节点
        parentElement
    获取前一个节点
        previousSibling
    获取后一个节点
        nextSibling

1.4 节点属性
    nodeName
        document  #document
        element   标签名
        attr      属性名
        text      #text
        comment   #comment
    nodeValue
        document  null
        element   null
        attr      属性值
        text      文本内容
        comment   注释内容
    nodeType
        document  9
        element   1
        attr      2
        text      3
        comment   8
</code></pre><h3 id="2-节点操作"><a href="#2-节点操作" class="headerlink" title="2.节点操作"></a>2.节点操作</h3><pre><code>2.1 获取节点
    element: getE.../子节点/父节点/同辈节点..
    text     innerHTML  / 子节点/  同辈
    attr:    获取到元素节点.通过对应的属性名
             element.attr
             element.getAttributeNode(attrname) 获取属性节点
             element.getAttribute(attrname)  获取属性值

2.2 改变节点(改变节点的值) nodeValue
    element 无意义
    attr: 
        element.setAttribute(attrname,value)
        element.attr = value;

2.3 删除节点
    元素节点: removeChild(node) 需要找到父节点
    属性节点: 把属性值赋值为空 / removeAttribute()

2.4 替换节点
    属性节点: setAttribute(&quot;属性名&quot;,&quot;值&quot;)
    元素节点: replaceChild(新节点, 老节点) 

2.5 插入节点
    属性节点: 
        setAttribute(attrname,value)
        setAttributeNode(attrname).nodeValue
    插入元素节点:
        appendChild(node)   追加插入
        insertBefore(new_node, old_node) 指定位置插入

    元素节点: replaceChild(new_node, old_node) 

2.6 创建节点
    创建属性节点: document.createAttribute(attrname)
    创建元素节点: document.createElement(&apos;标签名&apos;)

2.7 克隆节点
     cloneNode()  默认false / true
</code></pre><h3 id="3-XML-对象"><a href="#3-XML-对象" class="headerlink" title="3. XML 对象"></a>3. XML 对象</h3><pre><code>node
nodeList
document
element
attr
text
comment
</code></pre><h3 id="4-HTMLElement对象"><a href="#4-HTMLElement对象" class="headerlink" title="4. HTMLElement对象"></a>4. HTMLElement对象</h3><pre><code>视口高度
    document.documentElement.clientHeight
文档高度
    document.documentElement.scrollHeight
</code></pre><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><pre><code>async javascript and xml  异步的js和xml
请求: 客户端向服务端请求一个文件
响应: 服务端 把文件内容 输出给客户端, 文件有输出才算真真的响应
传统的请求 通过地址栏 刷新去请求页面
AJAX 通过技术 偷偷的请求  F12 NETWROK xhr
</code></pre><h3 id="XMLHttpRequest对象-XHR"><a href="#XMLHttpRequest对象-XHR" class="headerlink" title="XMLHttpRequest对象 XHR"></a>XMLHttpRequest对象 XHR</h3><pre><code>2.1 概念
    XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。

2.2 常用属性
    readyState 请求响应的状态
        0 Uninitialized 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。
        1 Open open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。
        2 Sent Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。
        3 Receiving 所有响应头部都已经接收到。响应体开始接收但未完成。
        4 Loaded HTTP 响应已经完全接收。
    status HTTP的响应状态码
        200  成功响应
        304  文件来自于缓存
        404  文件不存在
        500  服务器未知错误
        503  服务器宕机,服务不可用
    responseText  获取服务端的响应文本

2.3 常用方法
    open()  初始化
        参1 method  GET/POST/HEAD
        参2 url 请求主体
        参3 是否同/异步  true(异步) false(同步)
        参4,5 认证用户名和密码
    send()  正式发送
        GET  无参
        POST 有可选参数
    setRequestHeader()  设置请求头信息
    setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);

2.4 事件句柄    onreadystatechange
    readyState的值一变化就触发
</code></pre><h4 id="AJAX-GET方式"><a href="#AJAX-GET方式" class="headerlink" title="AJAX-GET方式:"></a>AJAX-GET方式:</h4><pre><code>JS代码:
    function add(){
        var num1 = document.getElementById(&apos;num1&apos;).value;
        var num2 = document.getElementById(&apos;num2&apos;).value;

        // 创建请求对象
        var xhr = new XMLHttpRequest();

        // 事件回调
        xhr.onreadystatechange = function(){
            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                box.innerHTML = xhr.responseText;
            }
        }

        // 请求初始化
        xhr.open(&apos;get&apos;,&apos;./php/2.php?a=&apos;+num1+&apos;&amp;b=&apos;+num2,true);
        // 正式发送请求
        xhr.send();
    }

PHP代码:
     echo $_GET[&apos;a&apos;] + $_GET[&apos;b&apos;];
</code></pre><h4 id="AJAX-POST方式"><a href="#AJAX-POST方式" class="headerlink" title="AJAX-POST方式:"></a>AJAX-POST方式:</h4><pre><code>JS代码:
     function add(){
        var num1 = document.getElementById(&apos;num1&apos;).value;
        var num2 = document.getElementById(&apos;num2&apos;).value;

        // 创建请求对象
        var xhr = new XMLHttpRequest();

        // 事件回调
        xhr.onreadystatechange = function(){
            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                box.innerHTML = xhr.responseText;
            }
        }
        // 请求初始化
        xhr.open(&apos;post&apos;,&apos;./php/3.php&apos;,true);

        // 设置POST请求头信息
        xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);

        // 正式发送请求
        xhr.send(&apos;a=&apos;+num1+&apos;&amp;b=&apos;+num2);
    }

php代码:
    echo $_POST[&apos;a&apos;] + $_POST[&apos;b&apos;];
</code></pre><h3 id="处理json数据"><a href="#处理json数据" class="headerlink" title="处理json数据"></a>处理json数据</h3><pre><code>PHP   json_encode();     // 将数据转成JSON格式
      json_decode();    // 将JSON格式的数据转换成PHP识别数据

JS    eval()               // 将JSON数据转换成对象
      JSON.parse()
实例:
    js代码:
        function loadHtml(){
            // 创建对象
            var xhr = new XMLHttpRequest();

            // 事件回调
            xhr.onreadystatechange = function(){
                if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
                    box.innerHTML = &apos;&apos;;
                    // 获取JSON数据,转换成对象.
                    var jsonStr = xhr.responseText;
                    // eval(&quot;var obj = &quot;+ jsonStr);
                    // var obj = eval(&apos;(&apos;+jsonStr+&apos;)&apos;);
                    var obj = JSON.parse(jsonStr);
                }
            }
            // 请求初始化
            xhr.open(&quot;get&quot;,&quot;./php/4.php&quot;,true);

            // 正式发送请求
            xhr.send();
        }

PHP代码:
        $db = DB::table(&apos;user&apos;);
        $data = $db-&gt;select();

        echo json_encode($data); // 将data 装换成JSON格式;
</code></pre><h3 id="同步-和-异步"><a href="#同步-和-异步" class="headerlink" title="同步 和 异步"></a>同步 和 异步</h3><pre><code>open()的参3,用于控制是否同/异步
默认参数为true,表示请求是异步的,不会影响到程序其它部分的执行
参数为false.表示请求是同步的,将会阻塞程序的运行,直到响应完成之后才继续执行其他部分.
</code></pre><h3 id="Ajax与JSONP"><a href="#Ajax与JSONP" class="headerlink" title="Ajax与JSONP"></a>Ajax与JSONP</h3><pre><code>1.Ajax 无法跨域
2.JSONP:
    其实就是动态的创建一个script标签,给该标签的src地址,赋值一个指定域下的PHP文件.
    在PHP的文件之中,返回一个JS的函数调用代码,只要在JS页面中 定义这个PHP端的同名函数即可.

JSONP实例:
        &lt;script&gt;
           function makedata(obj){
                for(var i in obj){
                    box.innerHTML += i +&apos;:&apos;+ obj[i] + &apos;&lt;br&gt;&apos;;
                }
            }

            // JSON 的关键步骤
            function loadHtml(){
                // 创建一个script元素标签
                var script = document.createElement(&apos;script&apos;);
                // 给该标签设置SRC值
                script.src = &apos;http://127.0.0.1/code/php/jsonp.php/&apos;;
                // 将该标签放入页面中
                document.body.appendChild(script);
            }
        &lt;/script&gt;

        &lt;?php
            require &apos;./config.php&apos;;
            require &apos;./DB.class.php&apos;;

            $db = DB::table(&apos;user&apos;);

            $data = $db-&gt;find(6);
            echo &quot;makedata(&quot;.json_encode($data).&quot;)&quot;;
        ?&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS常用函数]]></title>
      <url>/2017/12/08/JS%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><pre><code>不常用：
        str.length         返回字符串长度（中文只占一个位置）
        str.anchor        锚点
        str.bold        加粗
常用：
        str.charAt(下标)    
        获取指定下标的字符，从0开始；

        str.indexOf(&apos;字串&apos;)    
        返回首个给定字串的索引位置，没有则返回-1；

        str.lastIndexOf(&apos;字串&apos;)
        返回最后一个给定字串的索引位置，没有则返回-1；

        str.concat(&apos;字串&apos;)
        向字串末尾追加字串，生成新字串；

        str.substr(下标)             截取从指定下标开始至结束的字串;
        str.substr(下标,步长)        截取从指定下标开始至步长的字串;

        str.substring(下标,下标)        根据给定下标范围截取字串,不含最大范围;
        str.slice(下标,下标)            同substring(支持负数,负数为倒叙)

        str.toUpperCase()            大写转换    
        str.toLowerCase()            小写转换

        str.replace(&apos;初始值&apos;,&apos;新值&apos;)        替换    也支持正则 /正则/g

        str.match(/正则/)
        正则匹配首个符合条件的字串,成功返回字串,失败返回null;

        str.search(/正则/)
        正则匹配首个符合条件的字串,成功返回该字串下标,失败返回-1;

        str.split()
        根据给定元素将字串切割成数组,默认(空)不分割,空字符代表全部元素;
</code></pre><h3 id="正则函数"><a href="#正则函数" class="headerlink" title="正则函数"></a>正则函数</h3><pre><code>原始字串:
        var str = &apos;123456789&apos;;             
正则声明:
        var reg = /^\d{3}$/;            
        var reg = new RegExp(/\w{6}/);

reg.test(str);
用正则匹配字串,成功返回true,不成功放回false;

reg.exec(str);
用正则匹配字串,成功返回关联形数组,失败返回NULL;
</code></pre><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><pre><code>var data = new Date();
创建一个时间;

setFullYear();        设置公元时间
getyear();            获取当前年数 (1990-至今)
getFullYear();        获取当前公元年
getMonth();            获取当前月
getDate();            获取当前日期 几号
getDay();            获取当前日  周几
getHours();            获取当前小时
getMinutes();        获取当前分钟
getSeconds();        获取当前秒
getMillseconds();    获取当前毫秒
getTime();            获取时间戳
getUTCHours();        获取UTC时间

toString()            同date输出
toUTCString()        UTC时间字串
toLocaleString()    本地时间字串
</code></pre><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><pre><code>Math.PI            圆周率
Math.E            自然常数
Math.abs        绝对值
Math.sqrt        开根号
Math.max        最大数
Math.min        最小数
Math.floor        舍小取整
Math.ceil        进一取整
Math.round        四舍五入
Math.random        随机数

银行家四舍六入
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP]]></title>
      <url>/2017/12/08/PHP/</url>
      <content type="html"><![CDATA[<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法;"></a>基础语法;</h3><pre><code>1.PHP 定界符
所有的PHP代码必须放在定界符中才能起作用

&lt;?php 代码内容 ?&gt;       长风格
&lt;? 代码内容 ?&gt;          短风格
需要开启 short_open_tag = on

在wamp配置文件bin下的apache下bin下的php.ini
注意点:修改任意配置文件,只有重启服务器之后才会生效

2.设置字符集
header(&apos;content-type: text/html; charset=utf-8&apos;);

3.注释
//      单行注释
#       单行注释
/**/    多行注释
</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量;"></a>变量;</h3><pre><code>variable
定义变量 $变量名 = 值
未定义变量 $变量名 (不给值)

变量的命名规范 区分大小写
有数字,字母和下划线组成,不能以数字开头

可变变量: 将一个变量的值 作为另一个变量的名字去使用
引用变量:
        传值 只传变量的值
        传址 把值和内存地址都传了,在重新赋值后,被传址的变量也会跟着改变
三大类型,八大变量
标量类型:
        整形      int
      浮点型       float
      布尔型       bool  true/false
      字符串       string

复合类型:
        数组      array
        对象      object

特殊类型:
        资源      resource
        空           null

7种与false等价的情况,其余都认为true
    1. false
    2. 0
    3. 0.0
    4. &apos;&apos;或 &apos;0&apos;
    5. array()
    6. null
    7. 未定义变量
自动类型转换;
    1. 布尔型的true = 1 false = 0 (整形)
    2. null = 0  (整形)
    3. 字符串转数值型（integer、float)时，需注意以下几点：
         3.1 非数字的都等于0
         3.2 支持科学计数法  1e3 = 1000 或 .1E3 = 100
         3.3 遇到重复出现.或科学计数法的时候，以第一个为准，后面都无效。
         3.4 转换运算时，变量类型的转换优先级为float &gt; integer
强制类型转换:
        (变量类型)$变量名

        intval(变量名)
        floatval(变量名)
        strval(变量名)
常量;
用来表示程序中经常不变的值

格式1: const 常量名 = 常量值
格式2: define(常量名,常量值, [true/false])常用
        true : 不区分大小写
        false: 区分大小写(默认) 推荐
注意:
    常量值 一旦定义就不能再重复赋值/定义
    常量名推荐用大写
</code></pre><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符;"></a>运算符;</h3><pre><code>算术运算符
    + -
    *
    /
    % 取模 取余数 第二个数永远取绝对值,结果只会0~第二个数(不包括第二个数)

    ++ 递增 在前先+1在运算.++在后先运算,再+1
    -- 递减
    .  拼接符

赋值运算符
    =
    +=
    -=
    *=
    /=
    %=
    .=
    a += b 等于 a = a + b

比较运算符
    结果只有 true或false
    &gt;
    &gt;=
    &lt;
    &lt;=
    ==
    ===
    !=  或 &lt;&gt; 不等于
    !== 不全等 只有数值和类型都相等的情况下为false,其余都是true.

逻辑运算符
    &amp;&amp;      逻辑与  同and
    两边为真即为真,一边为假即为假

    ||      逻辑或  同or
    两边为假即为假,一边为真即为真

    !       逻辑非 反义

三元运算符
    格式:条件表达式 ? true : false
</code></pre><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制;"></a>流程控制;</h3><pre><code>顺序结构: 代码从上往下一次执行

分支结构: 通过if/switch来进行分支选择

if 适合定值判断 和 范围判断

    分支1:
        if(条件表达式)
        只能影响紧跟在if后面的一句话

    分支2:
        if(条件表达式){
        影响括号内的所有代码
        }

    分支3:
        if(条件表达式){
            true
        }else{
            false
        }

    分支4:
        if(条件表达式){
            true
        }elseif(条件表达式){
            true
        }else{
            false
        }

    分支5:
        switch(定值){
            case &apos;定值1&apos;: break;
            case &apos;定值2&apos;: break;
            case &apos;定值3&apos;: break;
            case &apos;定值4&apos;: break;
            ...
            [ default ]
        }
循环结构: 通过循环不断重复某些事情
    循环三要素:
        * 初始值
        * 循环条件
        * 循环增量

    1. while
        格式:

            a.初始值
            while( b.循环条件 ){
                c.循环体
                [循环增量]
            }
            d.其他内容

    2. do while
        格式:

            a.初始值
            do{
                b.循环体[循环增量]
            }while(c.循环条件);

            d.其余内容

    3. for
        格式:
            for(a.初始值; b.循环条件; c.循环增量){
                    d.循环体
            }
            e.其余内容
</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数;"></a>函数;</h3><pre><code>定义: 用来执行特定的任务,简称 功能

函数的分类:
    1. 系统函数: 数字,字符串,数组,时间,正则,文件...
    2. 自定义函数: 根据用户具体需求封装函数

自定义函数
    function 函数名(参数1,参数2,....){
        函数体
        [return 返回值]
    }

1. 关键字: function
2. 函数名: 不区分大小写
3. () : 定义/声明函数时的参数叫做形式参数,简称形参
4. {} : 函数体,函数功能的具体代码
5. return : 函数的返回结果

特性: 函数不调用,不会执行

函数的命名形式

    注意点:命名不能重复,不能与已有的函数名冲突,不区分大小写

1.驼峰命名法
    从第二个单词开始首字母大写
    addUserName()

2.帕斯卡命名法(大驼峰命名法)
    每个单词首字母都大写
    AddUserName()

3.下划线命名法
    每个单词之间用下划线隔开
    var_dump()

形参和实参:
    声明函数时的参数, 形参 =&gt; 形式参数
    调用函数时的参数, 实参 =&gt; 实际参数

    实参个数 = 形参个数
    完美

    实参个数 &gt; 形参个数
    后来的实参,没人要.

    实参个数 &lt; 形参个数
    多余的形参, 有默认值 =&gt; 采用默认值
                无默认值 =&gt; 采用未定义变量

函数返回值 return
    没有return, 默认返回null
    有return, 返回任意类型的值

注意:
    1.当函数碰到return,立马返回到调用函数的地方,函数不在执行了.
    2.当函数没有return时,等函数体执行完毕,自然回到调用函数的地方.

可变长度的参数函数:
    当实参个数不确定时,可以使用以下三个函数.
    1.func_get_args()       获取所有的实参(索引数组)
    2.func_get_arg(num)     获取下标为num的实参
    3.func_num_args()       获取实参的总个数

变量的作用域
    1.局部变量:在函数内部声明的变量,即为局部变量.
    2.全局变量:在函数外部声明的变量,即为全局变量.
    默认情况下,局部变量和全局变量互不影响.

    在局部使用全局的变量:
        函数外 $a = 100;
        函数内 $GLOBALS[&apos;a&apos;];

    在全局使用局部变量:
        函数内 $c= 100;
               GLOBAL $c;
        函数外 调用函数

    3.静态变量:特殊的局部变量,在函数结束的一瞬间,不会被删除.静态变量依旧不能再全局使用,普通局部变量:在函数结束的一瞬间被删除了.

可变函数
    将一个函数名当成变量来使用

回调函数

        求和函数
        function sum($num1, $num2)
        {
            return $num1 + $num2;
        }
        求积函数
        function mul($num1, $num2)
        {
            return $num1 * $num2;
        }

        PHP 回调函数
        function result($num1, $num2, $calllback)
        {
            return $calllback($num1, $num2);
        }

        echo result(10, 20, &apos;sum&apos;);

        echo result(10, 20, &apos;mul&apos;);

        系统回调函数
        把第一个参数作为回调函数调用
        echo call_user_func(&apos;sum&apos;, 50, 90);

        echo call_user_func(&apos;mul&apos;, 50, 90);

        调用回调函数，并把一个数组参数作为回调函数的参数
        echo call_user_func_array(&apos;sum&apos;, [10, 90]);

        echo call_user_func_array(&apos;mul&apos;, [10, 90]);

匿名函数和闭包
        $hehe = function($a)
        {
            echo $a;
        };

        $hehe(&apos;呵呵哒&apos;);

        var_dump($hehe);


        要在匿名函数内部 使用外部的变量时
        必须通过关键use,来连接闭包函数和外部的变量(全局变量)

        $func = function() use(&amp;$x,&amp;$y)
        {
            $x *= 2;
            $y *= 3;
            $z = $x + $y;
            return $z;
        };

        $x = 3;
        $y = 3;

        echo $func();


        局部变量的应用
        function demo()
        {
            $m = 3;
            $n = 3;

            闭包函数
            $func = function() use($m,$n)
            {
                $m *= 2;
                $n *= 3;
                $p = $m +$n;
                return $p;
            };
            return $func();
        }

        echo demo();
</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组;"></a>数组;</h3><pre><code>1.索引数组: 下标为纯数字
2.关联数组: 下标为非纯数字

查询数组中的某个值       $数组名[&apos;下标&apos;]
修改数组中的某个值       $数组名[&apos;下标&apos;] = 值
删除数组中的某个值       unset($数组名[&apos;下标&apos;])

遍历数组
    foreach(数组名 as 键 =&gt; 值){
        循环体
    }

超全局数组
    $GLOBALS    获取全局所有可以用的变量
    $_GET       获取以get方式传输的值
    $_POST      获取post方式传输的值
    $_FILES     专门接受上传文件
    $_COOKIE    存储cookie的值,浏览器
    $_SESSION   存储session的值,服务器
    $_REQUEST   存储get,post,cookie的值
    $_SERVER    获取文件地址,协议,IP,参数,网址,服务器...

        HTTP_HOST           主机名
        HTTP_USER_AGENT     设备来源,浏览器版本
        HTTP_REFERER        上一级的来源地址

        SERVER_SOFTWARE     服务器环境
        SERVER_NAME         服务器名 = 主机名
        SERVER_ADDR         服务器IP地址

        REMOTE_ADDR         客户端IP地址

        SCRIPT_FILENAME     脚本文件地址(盘符)
        SCRIPT_NAME         脚本文件地址(网址)

        REQUEST_METHOD      传输方式
        QUERY_STRING        传输参数
        REQUEST_URI         传输地址(带参数)
</code></pre><h3 id="正则"><a href="#正则" class="headerlink" title="正则;"></a>正则;</h3><pre><code>匹配一次正则
preg_match(正则,字符串,[结果])
返回值:成功匹配的个数 0:没有匹配到. &gt;0:匹配到的个数

全部匹配
preg_match_all(正则,字符串,[结果])

过滤数组
preg_grep(正则,数组)

替换字符
preg_replace(正则,替换后的值,替换前的值)
</code></pre><h3 id="时间-函数"><a href="#时间-函数" class="headerlink" title="时间(函数);"></a>时间(函数);</h3><pre><code>设置时区
    date_default_timezone_get()     获取当前时区
    date_default_timezone_set()     设置当前时区
    UTC  世界标准时间
    PRC  中华人民共和国

time() 获取当前时间的时间戳,从1970.1.1到当前的秒数 格林威治时间.

date : 格式化时间
date( 日期格式 ,[时间戳] ); 默认当前时间
echo date (&apos;Y-m-d H:i:s&apos;);
这个时间会受到时区的影响

创建时间点
mktime(时,分,秒,月,日,年)     返回值:时间戳

字符串转成时间
strtotime(&apos;文本&apos;)         返回值:时间戳

微秒数
microtime()
</code></pre><h3 id="错误"><a href="#错误" class="headerlink" title="错误;"></a>错误;</h3><pre><code>PHP程序的错误发生一般属于以下三种情况:
    1. 语法错误
        最常见,容易修复.
        会阻止脚本程序的执行

    2. 运行时错误
        比较常见,不会阻止脚本程序的执行

    3. 逻辑错误
        最麻烦的错误,既不会阻止脚本程序的执行,也不报错

错误级别
    1. error        致命错误,结束整个程序
    2.warning       警告错误,不会结束程序,但可能对结果造成一定的影响
    3. notice       提示错误,基本不会对程序造成影响

动态屏蔽错误
    方法1:
     在错误变量前面添加一个符号: @ 错误抑制符

    方法2:
     error_reporting() 对当前文件设置错误级别

     error_reporting(0);
     error_reporting(E_NOTICE);
     只报notice

     error_reporting(E_WARNING);
     只报warning

     error_reporting(E_ALL);
     全报错

     error_reporting(E_ALL &amp; ~ E_NOTICE);
     error_reporting(E_ALL ^E_NOTICE);
     除了notice不报,其余都报.

静态屏蔽错误
    方法1:
        修改配置文件
            display_errors = On / Off

    方法2:
        修改配置文件
            error_reporting = E_ALL
                              E_NOTICE
                              E_WARNING
                              E_ALL $ ~ E_NOTICE
                              ...

    方法3:
        模拟修改配置文件
        ini_get()       获取配置文件的值
        ini_set()       设置配置文件的值(临时)

自定义报错
    trigger_error(报错信息,报错级别)

设置错误日志
    error_log(p1, p2, p3)
    p1: 报错信息
    p2: 消息类型  类型3:将错误信息存储到指定文件
    p3: 指定文件
</code></pre><h3 id="文件"><a href="#文件" class="headerlink" title="文件;"></a>文件;</h3><pre><code>删除目录
rmdir()     只能删除空目录

剪切重命名
rename()    适合文件和目录
rename(剪谁,剪哪儿去)

rename(重命名谁,改成什么新名字)

文件加载
include &apos;文件路径&apos;;
include_once &apos;文件路径&apos;;    之家在一次相同文件

文件依赖
require &apos;文件地址&apos;;
require_onec &apos;文件地址&apos;;

include 和 require 有什么区别?
1. include 加载出错, 不会终止程序的执行
      require 加载出错, 终止程序的执行

2. 文件地址: 都支持相对路径, 盘符路径, 不支持网址路径

向文件赋予内容(先将文件大小截为0,然后再写内容)
file_put_contents(&apos;文件地址&apos;,&apos;内容&apos;);

获取文件内容
file_get_contents(&apos;文件地址&apos;)

打开文件,返回资源
fopen(&apos;文件地址&apos;,&apos;读写方式&apos;)

读取文件资源
fread(资源,长度)

写入文件
fwrite(资源,内容)

关闭资源
fclose(资源)

复制并移动
copy(&apos;数组名[值]&apos;,&apos;文件路径&apos;)

文件上传

上传文件,会有三个地方限制文件大小:
1.前端表单限制
    在前端表单中添加隐藏域
    name=&apos;MAX_FILE_SIZE&apos; value=&quot;字节&quot;

2.前端post协议
    配置文件 post_max_size = 8M
    如果违反这条,$_FILES将接受不到任何值

3.服务器端的配置文件限制
    配置文件 upload_max_filesize = 2M

文件下载
1. 接收 下载的文件名
    $name = $_GET[&apos;name&apos;];

    $suffix = strrchr($name, &apos;.&apos;);

2. 准备下载的路径
    $path = &apos;./download/&apos;.$name;

3. 实现下载
    header(&apos;content-Disposition:attachment; filename=&quot;&apos;.md5(uniqid()).$suffix.&apos;&quot;&apos;);

    readfile($path);
</code></pre><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP;"></a>OOP;</h2><pre><code>类的定义
    class 类名
    {
        属性(我有什么)
        方法(我会什么)
    }

    实例化类 = 对象
    $对象名 = new 类名
    $对象名 = new 类名()

    使用对象的属性
    $对象名-&gt;属性名

    使用对象的方法
    $对象名-&gt;方法名();

伪对象
    $this : 表示当前对象
    $this-&gt; 属性名
    $this-&gt; 方法名()

构造方法
    public function __construct(参数)
    {
        方法体
    }

    说明:
        1.在实例化瞬间,自动执行
        2.无返回值
        3.不允许重复

    作用:
        1.常用于给属性赋初始值,通常卸载成员属性的最后面,方法的最前面

析构方法
    public function __destruct()
    {
        方法体
    }

    说明:
        1.当对象销毁后,自动执行.
        2.当程序全部结束
        3.当对象变量被重新赋值/销毁后

当构造 与 析构同时出现时,先做构造,在做析构.
数据抽象层PDO

    $dsn = &apos;mysql:dbname=表名; host=localhos; charset=utf8&apos;;
    $user = &apos;root&apos;;
    $pwd = &apos;&apos;;

    exec()          更适合增删改,返回受影响的行数.
    query()         查询,返回PDOStatement类
    errorInfo()     返回错误信息
    lastInserId()   返回上一次插入的ID

    PDOStatement类
        fetch()     返回一条数据,一位数组.
        fetchALL()  全部返回二位数组
                PDO::FETCH_ASSOC    关联数组
                PDO::FETCH_NUM      索引数组
                PDO::FETCH_BOTH     混合数组
</code></pre><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性:"></a>面向对象的三大特性:</h3><pre><code>封装性
    1.将对象的属性和方法结合在一起,形成一个不可分割的独立单位(对象)
    2.信息隐蔽,尽可能的隐藏对象内部的属性和方法,只留下部分几口与外部联系.

如何控制与外部的联系?
    修饰符:
        public      公共的
        private     私有的
        protected   受保护的

                    类外    类内     继承
        public       √       √       √
        private      x       √       x
        protected    x       √       √

继承性
    定义:子类继承父类的属性和方法
    父类:基础类,基类
    子类:派生类,继承类,扩展类

    格式:
        class 子类名 extends 父类名
        {

        }

    特性:
        1.可继承属性,方法
        2.可重写属性,方法
        3.支持单继承,不支持多继承,可以有多个子类继承同一个父类.

    在子类调用父类的方法
    parent::方法名();
    子类中不能调用父类的属性

    访问级别:在继承时,方法和属性的重写,子类的访问级别不能大于父级的访问级别.
    private &gt; protected &gt; public
    private 不能被继承

多态性
    静态static

        格式:
            static 修饰符 属性名
            修饰符 static 属性名

            static 修饰符 属性名 = 值
            修饰符 static 属性名 = 值

        特性:
            1.静态不属于对象,只属于类
            2.静态可以定义属性和方法
            3.在静态方法内,只能访问静态属性/方法,$this不能在静态方法内使用
            4.静态属性/方法 可以被继承

        外部访问格式
            类名::属性名
            类名::方法名()

        内部访问格式
            self::属性名
            self::方法名()

            类名::属性名
            类名::方法名()
常量const
    面向对象中,定义常量只有通过const关键字

    1.定义格式:推荐大写
    const 常量名 = 值

    2.常量不属于对象,属于类
    类名::常量名

    3.常量区分大小写

    4.常量在同类中不能重复定义

    5.常量可以被继承,在继承类中可以重写一次

最终final
    1.只能修饰类和方法,不能修饰属性
    2.类不能被继承
    3.方法可以被继承,但不能重写

    总结:final类,并没有给类增加额外的功能,反而限制了原来的一些功能,主要用于保护类的结构.
</code></pre><h4 id="运算符关键字-滴血认清"><a href="#运算符关键字-滴血认清" class="headerlink" title="运算符关键字(滴血认清)"></a>运算符关键字(滴血认清)</h4><pre><code>instanceof
1.对象是否是类的实例
2.对象是否是类的子类

格式:
    (对象名 instanceof 类名)
    返回值:true/false
</code></pre><h4 id="克隆-clone"><a href="#克隆-clone" class="headerlink" title="克隆 clone"></a>克隆 clone</h4><pre><code>如果想给对象做个副本(备份)
1.clone 之后不需要实例化,直接当对象使用
2.clone之后,与原来的对象,互不影响,完全独立.

注意:直接赋值后的对象,会随着原来的对象变化而变化
删除,标识
直接赋值,删除对象.只是删除的对象与标识的连接,而不是内存的连接
</code></pre><h4 id="对象串行化"><a href="#对象串行化" class="headerlink" title="对象串行化"></a>对象串行化</h4><pre><code>作用:将对象串行化为字符串,存入文件,数据库,传递...
1.serialize()       串行化
2.unserialize()     还原对象

注意:只串属性,不串方法,但是方法依旧存在.
</code></pre><h4 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h4><pre><code>__autoload
作用:当实例化不存在的类时,自动触发.直接在外部使用,不需要在类内使用.
</code></pre><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><pre><code>abstract
作用:可以修饰类 和 方法

格式:
    abstract class 类名
    abstract 修饰符 function 方法名
    修饰符 abstract function 方法名

没有方法体的方法,都称为抽象方法.
    1.一个包含抽象方法的类,必须是抽象类.
    2.抽象类中不一定就要有抽象方法.
    3.抽象类不能实例化
    4.抽象类通常是由子类继承,并完善抽象方法.
    5.当类中全部为抽象方法时,称之为接口.
</code></pre><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><pre><code>interface 接口名
{

}

继承接口用implements
格式:
    class 子类名 implements 接口名
    {

    }

案例:
    interface USB
    {
        public function run();
    }

    class Mouse implements USB
    {
        public function run()
        {
          echo &apos;鼠标&apos;;
        }
    }

    class KeyBoard implements USB
    {
        public function run()
        {
          echo &apos;键盘&apos;;
        }
    }

    class Computer
    {
        public function start(USB $obj)
        {
            obj-&gt;run();
        }
    }

    $a = new Computer;
    $b = new Mouse;
    $c = new KeyBoard;

    $a-&gt;start($b);      鼠标
    $a-&gt;start($c);      键盘

1.使用接口来实现多态性,对于同一个接口,传入不同的参数,得到不同的结果.
2.PHP不支持多继承,但一个子类可以继承多个接口.
</code></pre><h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><pre><code>1.数组
2.对象

在函数或方法设定形参时,可以通过类型约束,限定形参的类型.
格式:
    function A (类型名 形参)
</code></pre><h4 id="对象的迭代"><a href="#对象的迭代" class="headerlink" title="对象的迭代"></a>对象的迭代</h4><pre><code>foreach
    遍历对象,只能遍历public的内容.
</code></pre><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><pre><code>1. __get()          在访问非公有属性时,自动调用.
2. __set()          在设置非公有属性时,自动调用
3. __isset()        在判断非公有属性是否设置为空时,自动调用.
4. __unset()        在判断非公有属性是否删除时,自动调用.
5. __call()         在访问不存在的方法时,自动调用.
6. __toString()     在直接输出对象时,自动调用.必须返回字符串,不能是其他类型.
7.__callStatic()    当访问不存在的静态方法时,自动调用.
8.__clone()         在克隆对象时,自动触发.(可以对副本重写一些属性)
9.__sleep()         在串行化时,决定显示的串行内容(返回数组).
10.__wakeup()       在还原对象时,可以修改内容.
</code></pre><h4 id="魔术常量"><a href="#魔术常量" class="headerlink" title="魔术常量"></a>魔术常量</h4><pre><code>__FILE__            当前盘符路径
__LINE__            当前的行数
__CLASS__           当前的类名
__METHOD__          当前的类下的方法名
__FUNCTION__        当前的方法名
</code></pre><h4 id="对象函数"><a href="#对象函数" class="headerlink" title="对象函数"></a>对象函数</h4><pre><code>class_exists(类名)                 判断类是否存在
property_exists(类名,属性名)     判断属性是否存在
get_class_vars()                 获取类中所有的公有属性
get_object_vars()                 获取对象中所有的公有属性
get_class_methods()             获取类中的所有的公有方法
get_class(对象)                     获取对象的类名
</code></pre><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理;"></a>异常处理;</h4><pre><code>异常类:
    Exception 类名(任意选个变量名)
    主动抛出异常:
        throw new Exception(&apos;报错内容&apos;);
格式:
    try
    {
        正常代码:
        $dsn = &apos;mysql:dbname=s0;charset=utf8;host=localhost&apos;;
        $user = &apos;root&apos;;
        $pwd = &apos;&apos;;

        主动抛出异常:
        throw new Exception();

        自动抛出异常:
        $pdo = new PDO($dsn, $user, $pwd);
        var_dump($pdo);

    }catch(Exception $e){
        处理异常:
        1. 获取发生异常的文件路径 (盘符)
        echo $e-&gt;getFile();

        2.获取发生异常的行号
        echo $e-&gt;getLine();

        3. 获取发生异常的信息
        echo $e-&gt;getMessage();

        4. 获取发生异常的编号
        echo $e-&gt;getCode();

    }

    当try下的正常代码出现错误的时候,catch会自动捕捉.

继承用法:
    class myException extends Exception
    {
        public function show()
        {
            $file = $this-&gt;getFile();
            $code = $this-&gt;getCode();
            $line = $this-&gt;getLine();
            $msg = $this-&gt;getMessage();
            include &apos;报错模板文件&apos;;
        }
    }

    指定一个函数进行异常处理,相当于catch操作:
    set_exception_handler(&apos;xx&apos;);

    function xx($e)
    {
        $e-&gt;show();
    }

    主动抛出异常:(相当于notice)
    throw new myException(对应该类下的方法);
</code></pre><h4 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制;"></a>会话控制;</h4><pre><code>允许服务器跟踪同一个客户端做出的连续请求;

客户端存cookie
    设置cookie
        setcookie(&apos;cookie名&apos;,&apos;cookie值&apos;);

    设置cookie生命周期
        setcookie(&apos;age&apos;, 18, time()+7*24*60*60 );

    设置cookie作用范围
        setcookie(&apos;sex&apos;, &apos;1&apos;, time()+7*24*60*60, &apos;/&apos; );

    设置cookie有效域名
        setcookie(&apos;hobby&apos;, &apos;preg&apos;, time()+7*24*3600, &apos;/&apos;, &apos;localhost&apos;);

    读取cookie
        var_dump($_COOKIE[&apos;sex&apos;]);

    修改cookie值
        setcookie(&apos;sex&apos; ,&apos;2&apos;, time()+7*24*3600, &apos;/&apos;);

    删除cookie值
        unset($_COOKIE[&apos;sex&apos;]);
        setcookie(&apos;sex&apos;, &apos;&apos;, time()-1, &apos;/&apos;);

服务器 session
    开启session
        session_start();

    设置 session
        $_SESSION[&apos;name&apos;] = &apos;wwb&apos;;

    修改 session
        $_SESSION[&apos;name&apos;] = &apos;jianglei&apos;;

    删除 session
        unset($_SESSION[&apos;name&apos;]);

    读取 session
        var_dump($_SESSION);
</code></pre><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式;"></a>设计模式;</h4><pre><code>单例模式:最终只能实例化一次对象,多次还是同一个对象.

1.不能让用户在外面new
2.一个对象都拿不到
3.通过普通方法去调用 构造方法
4.通过静态方法时调用 普通方法
5.通过连接标志,决定是否new self
案例:
    class MySQL
    {
        // $link 为空, 证明没有连接数据库
        // $link 非空, 证明你已经连接了数据库
        static protected $link;

        protected function __construct()
        {
            echo &apos;数据库连接成功了...&apos;;
        }

        static public function getConnect()
        {
            if(empty(self::$link)){
                self::$link = new self;
            }
            return self::$link;
        }
    }

MySQL::getConnect();
</code></pre>]]></content>
      
        <categories>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery]]></title>
      <url>/2017/12/08/jQuery/</url>
      <content type="html"><![CDATA[<h3 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h3><pre><code>1 什么是jQuery?
    jQuery是 JavaScript 的类库

2 jQuery版本
    jQuery 1.X    支持IE
    jQuery 2.X    IE9+  其他...
</code></pre><h3 id="jQuery的基本语法"><a href="#jQuery的基本语法" class="headerlink" title="jQuery的基本语法"></a>jQuery的基本语法</h3><pre><code>1.jquery标准的使用方式:
      1.1 JQ 标准入口
        $(document).ready(function() {
            (JS / JQ)代码
        });

    1.2 JQ 简写
        $(function() {
            (JS / JQ)代码
        });

    1.3 JS写法 
        window.onload = function () {
            (JS / JQ)代码
        }

2.ready和onload的区别
    1). 加载点
        ready 文档中 DOM加载完就触发
        onload 文档中的一且都加载完才触发
    2). 绑定
        ready可以多次绑定,且都会触发
        onload 后面的事件会覆盖前面

3.链式操作风格
    JQ.css().css();

4.jQueryDOM 与 JSDOM 的区别 以及相互转化
    区别:
        JQDOM  通过 $() 获取到的数组对象
        JSDOM  通过 原生方法 获取到的元素对象
    转换:
        JSDOM ---&gt; JQDOM    $(jsdom)
        JQDOM ---&gt; JSDOM    jqdom[index]

5.jquery命名冲突
    $ 的原意就是jQuery
    也可以var 变量 = jQuery;
</code></pre><h4 id="JQ-元素选择器"><a href="#JQ-元素选择器" class="headerlink" title="JQ 元素选择器"></a>JQ 元素选择器</h4><pre><code>1 基本选择器
    *                    通配符选择器
    #id                  ID选择器
    .class               CLASS选择器
    tagName              标签选择器
    selector,selector      组合/分组选择器

2 层级选择器
    selector selector  所有的后代元素
    selector&gt;selector  所有的子元素
    selector+selector  紧邻着的下一个元素
    selector~selector  紧邻着的所有元素

3 过滤选择器
    :first      首个
    :last       最后一个
    :eq(index)  指定第几个
    :lt(index)  索引小于
    :gt(index)  索引大于
    :odd         索引为奇数
    :even        索引为偶数 0也算作为偶
    :header      所有的h标签
    :not(selector) 排除

4 内容选择器
    :contains(text)  匹配包含指定文本的元素
    :has(selector)   匹配含有指定选择器的元素的元素
    :parent          匹配素有含子元素或非空的元素
    :empty           匹配所有空元素

5 可见性选择器
    :visible       匹配所有可见元素
    :hidden        匹配所有不可见元素

6 属性选择器
    selector[attrname]             选择有指定属性的元素
    selector[attrname=&apos;value&apos;]     值等于value的元素
    selector[attrname!=&apos;value&apos;]    值不等于value的元素
    selector[attrname^=&apos;value&apos;]    值以value的开头元素
    selector[attrname$=&apos;value&apos;]    值以value的结尾元素
    selector[attrname*=&apos;value&apos;]    值包含value的元素
    [][][] ....   多个属性选择器,用于做进一步筛选操作的

7 子元素选择器
    :first-child    是否是首个子元素
    :last-child     是否是最后一个子元素
    :nth-child(n)   是否是第N个子元素
    :only-child     是否是独子元素

8 表单选择器
    :input            
    :text
    :password
    :radio
    :checkbox
    :submit
    :reset
    :button
    :file
    :hidden
    :image

9 表单对象选择器
    :enabled   匹配所有可用元素
    :disabled  匹配所有不可用元素
    :checked   匹配所有被选中元素
    :selected  匹配所有选中的option元素
</code></pre><h4 id="JQ-筛选方法"><a href="#JQ-筛选方法" class="headerlink" title="JQ 筛选方法"></a>JQ 筛选方法</h4><pre><code>1.过滤
    :eq(index)           过滤出指定的某个
    :first()             过滤出首个
    :last()              过滤出最后一个
    :filter(selector)    过滤出满足前面条件的
    :not(selector)       过滤排除,与以上相反
    :slice(start, end)   截取出一段
    :has(selector)       含有指定选择器的元素的元素

    // 条件判断 返回布尔值;
    .hasClass()          判断前面的DOM集合中,是否包含指定class类
    .is()                判断前面的DOM集合中,是否有符合指定表达式的
    .map()               对JQDOM遍历,并且可以取得一部分值出来
2 查找
    (往里找)
        .children()       只找子元素
        .find()           找所有后代元素
    (往外找)
        .parent()         父元素
        .parents()        父元素们
        .parentsUntil()   父元素们,到指定的为止
        .offsetParent()   获取已定位的父元素
    (往后找)
        .next()           紧邻着的一个同辈元素(后)
        .nextAll()        紧邻着的所有同辈元素(后)
        .nextUntil()      紧邻着的同辈元素,直到指定的为止(后)
    (往前找)
        .prev()           紧邻着的一个同辈元素(前)
        .prevAll()        紧邻着的所有同辈元素(前)
        .prevUntil()      紧邻着的同辈元素,直到指定的为止(前)

        .siblings()       除了元素自己以外的所有同辈元素

3 串联
        .add()            向集合内追加新元素
        .andSelf()        之前选中的集合,加入到当前集合内
        .end()            返回最后一个 破坏性操作之前的样子
        .contents()       获取所有的子节点(包括文本)
</code></pre><h4 id="JQ-文档处理方法"><a href="#JQ-文档处理方法" class="headerlink" title="JQ 文档处理方法"></a>JQ 文档处理方法</h4><pre><code>1 内部插入
    .append()     内部最后
    .appendTo()   --
    .prepend()    内部最前
    .prependTo()

2 外部插入
    .after()       外部最后
    .insertAfter() --
    .before()       外部最前
    .insertBefore()  --

3 包裹
    .wrap()      将集合内的每个元素,包裹在指定元素内
    .wrapAll()   将整个集合元素,包裹在指定元素内
    .wrapInner()  包裹在里面
    .unwrap()    去掉包裹

4 替换
    .replaceWith()  替换谁
    .replaceAll()   谁被替换

5 删除
    .remove()   删除元素
    .empty()    清空子节点

6 复制
    .clone()
</code></pre><h4 id="JQ-属性方法"><a href="#JQ-属性方法" class="headerlink" title="JQ 属性方法"></a>JQ 属性方法</h4><pre><code>1 属性操作
    HTMLDOM
        .prop()         设置属性
        .removeProp()    删除属性
    XMLdom
        .attr()            设置属性
        .removeAttr()    删除属性

2 CSS 类  (class)
    .addClass()     添加一个类属性
    .removeClass()  移除一个类属性
    .toggleClass()   以上俩,来回切换

3 HTML代码/文本/值
    .html()   相当于innerHTML
    .text()   相当于innerText
    .val()    相当于.value 表单控件的值
</code></pre><h4 id="CSS-操作"><a href="#CSS-操作" class="headerlink" title="CSS 操作"></a>CSS 操作</h4><pre><code>连贯写法:
    css(&apos;attr&apos;, &apos;value&apos;).css(&apos;attr&apos;, &apos;value&apos;);
JSON写法:
    css({
        &apos;attr&apos;: &apos;value&apos;,
        &apos;attr&apos;: &apos;value&apos;,
        &apos;attr&apos;: &apos;value&apos;
    });
</code></pre><h4 id="位置类方法"><a href="#位置类方法" class="headerlink" title="位置类方法"></a>位置类方法</h4><pre><code>offset()     获取/设置 元素相对于body的位置  .left / .top
position()   获取 已定位的父元素的位置

scrollLeft() 获取/设置 滚动条距离左/上的像素值
scrollTop()
</code></pre><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><pre><code>    height()        获取/设置 css的元素宽/高
    width()

    innerHeight()      获取/设置 元素宽/高 +  内边距
    innerWidth()

    (标准盒子模型)
    outerHeight()     获取/设置 元素宽/高 +  内边距 + 边框
    outerWidth()

其他尺寸:
    $(window).height() //浏览器时下窗口可视区域高度
    $(document).height() //浏览器时下窗口文档的高度
    $(document.body).height()//浏览器时下窗口文档body的高度
    $(document.body).outerHeight(true)//浏览器时下窗口文档body的总高度 包括border padding margin
    $(window).width() //浏览器时下窗口可视区域宽度
    $(document).width()//浏览器时下窗口文档对于象宽度
    $(document.body).width()//浏览器时下窗口文档body的高度
    $(document.body).outerWidth(true)//浏览器时下窗口文档body的总宽度 包括border padding margin
    $(document).scrollTop() //获取滚动条到顶部的垂直高度
    $(document).scrollLeft() //获取滚动条到左边的垂直宽度
</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><pre><code>1 绑定事件
    1). 简写方式 : 
            JQDOM.event(function(){

            });
    2). 标准方式  
            JQDOM.bind(&apos;event&apos;, function(){

            });
    3). 一次性 事件 
            JQDOM.one(&apos;event&apos;, function(){

            });

2 解绑定
    unbind()

3 事件委派
    3.1) live() 事件委派  1.9-
        JQDOM.live({
            &quot;event&quot;:function (){
                // 内容
            },
               &quot;event&quot;:function (){
                // 内容
            }
        });

    3.2) on()   JQ 1.9+
        $(document).on(&apos;event&apos;, &apos;JQDOM&apos;, function (){
            // 内容
        }).on(&apos;event&apos;, &apos;JQDOM&apos;, function (){
            // 内容
        });

4 事件的自动触发
    JQDOM.trigger(&apos;event&apos;);
    // 自动触发的事件必须是已存在的!

5 阻止默认事件 和 事件冒泡
    在默认事件内 /  冒泡事件内 
    return false;
</code></pre><h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><pre><code>1 基本
    .show()
    .hide()
    .toggle()
2 滑动效果
    .slideDown()
    .slideUp()
    .slideToggle()
3 淡入淡出
    .fadeIn()
    .fadeOut()
    .fadeToggle()
    .fadeTo()   0为完全透明 1为不透明
4 自定义动画
    JQDOM.animate({
       // 内容

    },time);            自定义动画


   .stop()                停止
   .delay()                延时
</code></pre><h2 id="JQ-AJAX"><a href="#JQ-AJAX" class="headerlink" title="JQ-AJAX"></a>JQ-AJAX</h2><pre><code>1） load方式:
        JQDOM.load(&apos;URL地址&apos;);

2） GET方式:
        $.get(&apos;URL地址&apos;,function(参){
               // 响应处理行
        });

3） POST方式:
        $.post(&apos;URL地址&apos;,function(参){
               // 响应处理行
        });

4)  AJAX()方式: （推荐）
        $.ajax({
            type : &apos;Method&apos;,                
            url : &apos;URL&apos;,
            success : function(参){
                // 响应处理行
            },
            error : function(){
                // 错误处理行
            }
        });
</code></pre><h3 id="AJAX参数处理"><a href="#AJAX参数处理" class="headerlink" title="AJAX参数处理"></a>AJAX参数处理</h3><pre><code>1） GET/POST 演示：
        // 需要先获取参数内容；
            var num1 = $(&apos;#num1&apos;).val();
             var num2 = $(&apos;#num2&apos;).val();
         $.get(&apos;URL&apos;,{a:num1,b:num2},function(data){

        })；

2）ajax() 演示:
        $.ajax({
            type : &apos;post&apos;,
            url : &apos;URL&apos;,
            data : &apos;a=&apos;+num1+&apos;&amp; b=&apos;+num2,
            success : function(参){
                // 响应处理行
            },
            error : function(){
                // 错误处理行
            }
        });

 3) JS串行化数据:
        var info = $(&apos;#my input&apos;).serialize();
        // 前提要有表单,且name属性存在.串行化的数据可以直接送进data里;
</code></pre><h3 id="处理JSON数据"><a href="#处理JSON数据" class="headerlink" title="处理JSON数据"></a>处理JSON数据</h3><pre><code>1) GET/POST 方式:
        $.get(&apos;URL&apos;, function (参){

        },&apos;json&apos;);

2) ajax 方式:
        $.ajax({
            type : &apos;post&apos;,
            url : &apos;URL&apos;,
            dataType : &apos;json&apos;,
            success : function(参){
                // 响应处理行
            },
            error : function(){
                // 错误处理行
            }
        });
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js - express]]></title>
      <url>/2017/12/08/Node.js-express/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Express框架 基于 Node.js 平台，快速、开放、极简的 web 开发框架。 它是用于后台NodeJs的框架,与JQuery/Bootstrap/vue.js/AngularJs这类前端框架是不一样的! Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。</p>
<p>对比原生Node.js 使用原生Node.js开发,会发现有很多问题: - 呈现静态页面很不方便,需要处理每个HTTP请求,还要考虑304缓存问题. - 路由处理代码不直观清晰,需要写很多正则表达式和字符串函数. - 开发者不能集中精力写业务,要考虑很多其他的东西</p>
<p>官网：<a href="http://expressjs.com/" target="_blank" rel="noopener">http://expressjs.com/</a></p>
<p>中文官网：<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a></p>
<p>安装 npm install express –save<br>即可安装最新版本的Express;<br>Express4.x与3.x版本的差别非常大，我们讲解4.x</p>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code>1.引入框架模块
    var express = require(&apos;express&apos;);

2.创建服务器 
var app = express();

3.使用EJS模块
app.set(&apos;view engine&apos;, &apos;ejs&apos;);

4.对静态目录的处理(多MIME类型自动处理)
app.use(&apos;/static&apos;, express.static(&apos;./static&apos;));

5.设置默认路由规则
app.get(&apos;/&apos;, function (req, res) {
    res.send(&apos;hello, Express~&apos;);

6.设置GET路由
app.get(&apos;/test&apos;, function (req, res) {
    res.send(&apos;这是Test页面GET&apos;);
});

7.设置POST路由
app.post(&apos;/test&apos;, function (req, res) {
    res.send(&apos;这是Test页面POST&apos;);
});

8.设置EJS页面并输出
app.get(&apos;/users&apos;, function (req, res) {
    res.render(&apos;user&apos;, {
        &quot;userlist&quot; : [
            &apos;一拳超人&apos;,
            &apos;小金刚&apos;,
            &apos;白小飞&apos;,
            &apos;路飞&apos;,
            &apos;机器猫&apos;
        ]
    });
});

9.监听服务器(开启)
app.listen(3000);
</code></pre><h3 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h3><pre><code>路由的设置的基本格式:
    app.METHOD(PATH, HANDLER)
注释:
    用app调用请求方式(METHOD),请求路径(path),函数执行(handler);
    常用的请求方式(get,post,put)
</code></pre><blockquote>
<p>Express的路由处理机制很灵活,可以把它想象成漏斗形式.通过路由中间件的特性来逐个匹配各个路由规则,得到最终结果并返回;对路径大小写不敏感,且支持正则匹配路径和参数等;</p>
</blockquote>
<pre><code>实例:

    var express = require(&apos;express&apos;);
    var app = express();
    app.set(&apos;view engine&apos;, &apos;ejs&apos;);

    // 设置中间件,当接收到能匹配系统允许的请求方式时,都会进入这里,并通过next()传递下去;
    app.all(&apos;/t&apos;, function (req, res, next) {
        console.log(new Date().toString());
        next();
    });

    // 设置GET路由
    app.get(&apos;/t&apos;, function (req, res) {
        res.send(&apos;这是GET&apos;);
    });
    // 设置POST路由
    app.post(&apos;/t&apos;, function (req, res) {
        res.send(&apos;这是POST&apos;);
    });
    // 设置PUT路由
    app.put(&apos;/t&apos;, function (req, res) {
        res.send(&apos;这是PUT&apos;);
    });

    // 路由方法,默认匹配pathname部分
    // 对大小写不明感
    app.get(&apos;/aaa&apos;, function (req, res) {
        //  获取GET参数
        console.log(req.query);
        res.send(&apos;这是3A页面&apos;);
    });

    // 路由路径 正则规则   /stu/15156165/s70
    app.get(/^\/stu\/(\d{10})\/(\w+)$/, function (req, res) {
        // 正则中的子模式(括号)部分,可以用params取出
        res.send(&apos;学员学号: &apos; + req.params[0]);
        console.log(req.params);
    });

    // 路由参数
    app.get(&apos;/tch/:tid&apos;, function (req, res) {
        res.send(&apos;老师的工号: &apos; + req.params.tid);
        console.log(req.params);
    });

    // 多个路由参数,并作限制
    app.get(&apos;/goods/:name/:num&apos;, function (req, res) {
        var name = req.params.name;
        var num = req.params.num;
        if (/\d+/.test(num)) {
            res.send(&apos;商品名: &apos;+ name + &apos;,入库: &apos;+ num);
        } else {
            res.send(&apos;请填写正确的数量!&apos;);
        }
    });

    app.listen(3000);
</code></pre><h4 id="请求-响应-中间件"><a href="#请求-响应-中间件" class="headerlink" title="请求 响应 中间件"></a>请求 响应 中间件</h4><pre><code>1. 请求对象 req
    这里的req和原生里没有区别,返回的是请求对象的相关数据;
    常用方式:
        req.params        // 解析请求对象

2. 响应对象 res
    框架比起原生的使用方式显得更加直观和清晰;
    常用方式:
        res.download()        提示下载文件。
        res.end()            终结响应处理流程。
        res.json()            发送一个 JSON 格式的响应。
        res.jsonp()            发送一个支持 JSONP 的 JSON 格式的响应。
        res.redirect()        重定向请求。
        res.render()        渲染视图模板。
        res.send()            发送各种类型的响应。
        res.sendFile        以八位字节流的形式发送文件。
        res.sendStatus()    设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。
3. 中间件句柄 next
    简单理解的:如果你不希望这个请求在这里被终结,那就用next(),将它丢给其他路由去处理;而当一个路由用了next参数时,它就是一个中间件;
</code></pre><h4 id="路由重名"><a href="#路由重名" class="headerlink" title="路由重名"></a>路由重名</h4><pre><code>假设我们遇到路由重名问题,可以通过中间件来解决该问题;

实例:
    app.get(&apos;/kk&apos;, function (req, res, next) {
    console.log(1);
    next();
    });

    app.get(&apos;/kk&apos;, function (req, res) {
        console.log(2);
        res.end(&apos;KK响应完成&apos;);
    });
分析:
    如果不设置next()中间件,那访问/kk的时候,永远只会在log(1)的区间;因为log(2)的访问路径重名了,这里用next()可以完美解决这个问题;
</code></pre><h4 id="路由匹配冲突"><a href="#路由匹配冲突" class="headerlink" title="路由匹配冲突"></a>路由匹配冲突</h4><pre><code>在实际项目当中,很有可能会遇到路由匹配冲突的问题,我们同样可以通过中间件的方式来解决;    

app.get(&apos;/:goods/:num&apos;, function (req, res, next) {
    if (商品名判断) {
        console.log(1);
        res.send(&apos;商品: &apos;+ req.params.goods + &apos;数量: &apos;+ req.params.num);
    } else {
        next();
    }
});

app.get(&apos;/admin/login&apos;, function (req, res) {
    console.log(2);
    res.send(&apos;后台登录&apos;);
});

分析:
    因为路由1直接匹配参数,导致访问后续路由的时候,路径会被当成参数送到路由1里;这时候,我们需要加上中间件,并在路由1里做分支判断来解决;
</code></pre><h4 id="app-use中间件的使用"><a href="#app-use中间件的使用" class="headerlink" title="app.use中间件的使用"></a>app.use中间件的使用</h4><pre><code>app.use([path],function);
1.这个中间件的参1是选填的,参2方法是必填的;如果不填参1默认匹配根/,填参的话,会将参数当成根目录;
2.模糊匹配特性,比如参1为/user;它能够识别/user/.../...;
3.我们可以利用这个特性,让用户访问任何路径都能被识别;

实例:
    app.use(function(req, res, next) {
        console.log(new Date().toString());
        next();
    });

    app.use(function(req, res) {
        res.write(req.originalUrl + &quot;\n&quot;); // 完整的URL
        res.write(req.baseUrl + &quot;\n&quot;); // 基底URL,以这个作为基础
        res.write(req.path + &quot;\n&quot;); // 除去基底以外的子路径.
        res.end(&apos;后台&apos;);
    });

服务和404页面的实例:
    var express = require(&apos;express&apos;);
    var fs = require(&apos;fs&apos;);
    var app = express();
    app.set(&apos;view engine&apos;, &apos;ejs&apos;);

    // 静态资源服务
    app.use(&apos;/jingtai&apos;, express.static(&apos;./static&apos;));

    // 路由
    app.get(&apos;/admin&apos;, function (req, res){
        res.send(&apos;后台&apos;);
    });

    // 404的路由更改,必须在所有路由的末端;
    app.use(function(req, res, next) {
        res.status(404).render(&apos;err&apos;, {
            &quot;errlist&quot; : [
                &apos;您访问的页面不存在&apos;
            ]
        });
    });


    app.listen(3000);

分析:
    我们可以通过使用app.use的参数特性,伪装真实的目录名;
</code></pre><h3 id="GET和POST处理"><a href="#GET和POST处理" class="headerlink" title="GET和POST处理"></a>GET和POST处理</h3><pre><code>GET请求的参数在URL中.
原生node中,要想得到get参数,需要借助于url模块来识别参数字符串.
在Express中，不需要使用url模块了.可以直接使用`req.query`对象得到GET参数

GET请求的参数是隐蔽传参(在请求体中).
POST请求在Express中不能直接获得,必须使用`body-parser`模块.使用后,将可以用req.body得到参数.
但是如果表单中含有文件上传,那么还是需要使用`formidable`模块.
安装:
    npm i body-parser --save

实例:
    var express = require(&apos;express&apos;);
    var bodyParser = require(&apos;body-parser&apos;);

    var app = express();
    app.set(&apos;view engine&apos;, &apos;ejs&apos;);

    // 按照此值去解析post数据 application/x-www-form-urlencoded
    app.use(bodyParser.urlencoded({ extended: false }));


    // GET处理
    app.get(&apos;/&apos;, function (req, res){
        console.log(req.query);
        res.send(&apos;GET完成&apos;);
    });

    // 获取表单页面请求
    app.get(&apos;/form&apos;, function (req, res){
        res.render(&apos;form&apos;);
    });

    // POST处理(表单提交请求)
    app.post(&apos;/&apos;,function(req, res){
        console.log(req.body);
        res.send(&apos; POST完成&apos;);
    });

    app.use(function(req, res, next) {
        res.status(404).send(&apos;404 NOT FOUND&apos;);
    });


    app.listen(3000);
</code></pre><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><pre><code>http://www.expressjs.com.cn/guide/database-integration.html#mysql
支持的数据类型,要用什么数据库先安装,这里以MYSQL为例;
安装:
    npm i mysql --save

实例:
    var express = require(&apos;express&apos;);
    // 引入mysql模块;
    var mysql = require(&apos;mysql&apos;);
    var app = express();
    app.set(&apos;view engine&apos;, &apos;ejs&apos;);
</code></pre><h4 id="两种连接数据库方式"><a href="#两种连接数据库方式" class="headerlink" title="两种连接数据库方式:"></a>两种连接数据库方式:</h4><h5 id="1-池连接-推荐"><a href="#1-池连接-推荐" class="headerlink" title="1) 池连接(推荐)"></a>1) 池连接(推荐)</h5><pre><code>// 创建连接池
var pool = mysql.createPool({
    host: &apos;127.0.0.1&apos;,
    user: &apos;root&apos;,
    password: &apos;123456&apos;,
    database: &apos;s70&apos;
});

app.get(&apos;/pool&apos;, function (req, res) {
    pool.getConnection(function(err, connection){
        var sql = &quot;SELECT * FROM lover&quot;;
        connection.query(sql, function (error, result) {
            if (error) {
                console.log(&apos;执行出错: &apos; + error);
                return;
            }
            console.log(result);
            res.send(result);
        });
    });
});
</code></pre><h5 id="2-路由连接"><a href="#2-路由连接" class="headerlink" title="2) 路由连接"></a>2) 路由连接</h5><pre><code>app.get(&apos;/&apos;, function (req, res) {
    // 设置连接属性
    var connection = mysql.createConnection({
        host: &apos;127.0.0.1&apos;,
        user: &apos;root&apos;,
        password: &apos;123456&apos;,
        database: &apos;s70&apos;
    });
    // 开启数据库连接
    connection.connect(function (err) {
        if (err) {
            console.log(&apos;数据库连接错误: &apos; + err);
            return;
        }
        console.log(&apos;数据库连接完成!&apos;);
    });

    // 执行SQL语句;
    var sql = &quot;SELECT * FROM user&quot;;
    connection.query(sql, function (error, result) {
        if (error) {
            console.log(&apos;执行出错: &apos; + error);
            return;
        }
        console.log(result);
        res.send(result);
    });
    // 结束连接
    connection.end();
});
</code></pre>]]></content>
      
        <categories>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5]]></title>
      <url>/2017/12/08/HTML/</url>
      <content type="html"><![CDATA[<h2 id="HTML5-基本语法"><a href="#HTML5-基本语法" class="headerlink" title="HTML5 基本语法"></a>HTML5 基本语法</h2><pre><code>HTML5声明
doctype 文档类型
!docype html 声明以html5的规则去解析 W3C的标准


标签格式;
        单 &lt;标签名/&gt;
        双 &lt;标签名&gt; &lt;/标签名&gt;


注释;
    &lt;-- --&gt;
    1 对代码的描述
    2 不会显示在网页中
    3 有助于快速恢复记忆
    4 提高团队开发效率
    5 注释不能嵌套使用
</code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><h4 id="全局架构标签"><a href="#全局架构标签" class="headerlink" title="全局架构标签;"></a>全局架构标签;</h4><pre><code>html:
    表示该标签下的都是html代码.
head:
    头标签主要负责,声明网页的标题.
body
    网页主体,页面内容都显示在里面.
title
    主要负责网页的标题
</code></pre><h4 id="文本格式标签"><a href="#文本格式标签" class="headerlink" title="文本格式标签;"></a>文本格式标签;</h4><pre><code>h1-h6   标题标签
p       段落
b       加粗
i       倾斜
u       下划线
br      换行
hr      分割线
del     删除线
strong  加粗强调
u       倾斜强调
sub     上标标签
sup     下标标签
pre     原样输出
</code></pre><h4 id="列表"><a href="#列表" class="headerlink" title="列表;"></a>列表;</h4><pre><code>ul      无序列表
ol      有序列表
li      配合ul和ol使用
dl      定义列表
dt dd   配合定义列表使用
</code></pre><h4 id="实体符号"><a href="#实体符号" class="headerlink" title="实体符号;"></a>实体符号;</h4><pre><code>&amp;lt;    小于号
&amp;gt;    大于号
&amp;nbsp;  空格
&amp;yen;   人民币
&amp;copy;  版权符号
&amp;copytight;
</code></pre><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接;"></a>超链接;</h4><pre><code>标签      a
属性:
    href    目的路径
    target
           _blank   在新窗口打开链接
           _self    在本窗口打开链接(默认)
    title
        当鼠标悬停在超链接上时,显示title内容.
网址的组成:
    1.协议 : http https ftp file ....
    2.域名 : www.baidu.com =&gt; ip地址 118.242.0.155
    3.目录 : image/start/xx/hehe.jpg 网址最终要访问的地方
        ? 之前: 网址的所在位置
        ? 之后: 访问此网址所带的参数
    4.参数: 参数名=参数值  (多个参数:用&amp;隔开)
    5.锚点:
    #锚点名
    通过name属性设置锚点名称，通过href=&quot;链接#锚点名&quot;设置点击跳转。
</code></pre><h4 id="多媒体图片"><a href="#多媒体图片" class="headerlink" title="多媒体图片;"></a>多媒体图片;</h4><pre><code>    标签  img
    属性:
        src     图片来源地址
        width   宽度
        height  高度
        title   当鼠标悬停在图片上时,显示title内容
        alt     代替无法显示时的内容

相对路径
    ./      当前目录下   (默认,可以省略)
    ../     上一级目录下
    ../../  上上级目录下

绝对路径
    盘符路径  C:/wamp/xx/x/x/x/x/xxx.jpg
    网址路径 http://www.baidu.com/x/x/x/x.jpg

    经过服务器: 推荐
        认识网址
        / : 当成www/ 等于 lovalhost/

    不经过服务器
        认识判读
        认识网址
        / : 当成 当前所在的盘符
</code></pre><h4 id="多媒体音频-视频"><a href="#多媒体音频-视频" class="headerlink" title="多媒体音频/视频;"></a>多媒体音频/视频;</h4><pre><code>音频标签    audio
属性:
    src         音频来源地址
    controls    播放器
    Loop        循环播放
    autoplay    自动播放

视频标签    video
属性:
    src         视频来源地址
    controls    播放器
    loop        循环播放
    autoplay    自动播放

兼容性问题, 通过媒介标签 source来解决
</code></pre><h4 id="表格-table"><a href="#表格-table" class="headerlink" title="表格      table"></a>表格      table</h4><pre><code>    表格标题    caption
    表行      tr
    表头      th
    单元格     td

常见表格属性:
    border          边框
    cellspacing     外边距
    cellpadding     内边距
    align           水平对齐
        left,center,right
    valign          垂直对齐
        top,middle,bottom
    rowspan         行合并
    colspan         列合并
    width
    height
    bgcolor         背景颜色
    background      背景图片
</code></pre><h4 id="表单"><a href="#表单" class="headerlink" title="表单;"></a>表单;</h4><pre><code>声明标签:       form
    属性:
        action : 提交到哪儿去,服务器的脚本地址
        method : 传输方式 get post
        enctype: multipart/form-data
        只有文件上传时,才需要
注意:
1. 每个表单都必须加上name,没有name值,服务器则接收不到表单.
2. 可手动输入表单:value可写可不写
   不可手动输入的表单:value 必须写

表单标签:      
    类型:
   input type = text            文本域
                password        密码域
                radio           单选框
                checkbox        多选框
                file            文件上传
                hidden          隐藏域
                email           邮箱
                number          数字
                url             网址
                data            日期
                search          搜索

                submit          提交
                reset           重置
                button          自定义按钮

    select  下拉框
        option      下拉框子选项
        optgroup    对子选项分组
        label       组名

    textarea        多文本域
        rows        行
        cols        列

    字段集标签
        fieldset    外框
        legend      标题名

常见表单属性
        placeholder     背景字
        maxlength       最大长度
        minlength       最小长度
        checked         单/多选默认选中
        selected        下拉框默认选中
        autofocus       默认焦点选中
        autocomplete    自动提示   on / off
        readonly        只读
        disabled        禁用
        required        不能为空
        multiple        多选值
</code></pre><h4 id="分帧"><a href="#分帧" class="headerlink" title="分帧;"></a>分帧;</h4><pre><code>小分帧标签       iframe
    属性:
        src             窗口内容来源
        frameborder     窗口边框 0/ 非0
        scrolling       滚动条是否显示 yes/no
        name            给本窗口取个名字
                        通过a标签跳到指定的窗口
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js(2)]]></title>
      <url>/2017/12/08/node.js(2)/</url>
      <content type="html"><![CDATA[<h3 id="POST数据处理"><a href="#POST数据处理" class="headerlink" title="POST数据处理"></a>POST数据处理</h3><blockquote>
<p>相比较GET请求，POST请求比较复杂。因为Node.js认为，使用POST请求时，数据量会比较多。为了追求极致的效率，它将数据拆分成为了众多小的数据块(chunk)，然后通过特定的事件，将这些小数据块有序传递给回调函数。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
var querystring = require(&apos;querystring&apos;);
</code></pre></blockquote>
<pre><code>var server = http.createServer(function (req, res) {
    // 这里的req是指访问页面的GET请求;
    if (req.url == &apos;/form&apos;) {
        fs.readFile(&apos;./form.html&apos;, function (err, data) {
            res.writeHead(200, {
                &quot;Content-Type&quot;: &quot;text/html;charset=UTF-8&quot;
            });
            res.end(data);

        });
    } else if (req.url == &apos;/dopost&apos; &amp;&amp; req.method.toLowerCase() == &apos;post&apos;) {
        var postData = &apos;&apos;;
        // 监听并处理POST请求;这里data是固定参数;
        req.addListener(&apos;data&apos;, function (chunk) {
            postData += chunk;
        });
        // node为了追求极致效率,将POTS数据分割为小块的形式进行传输

        // 全部传输完成,参1改成end,参2处理回调逻辑;
        req.addListener(&apos;end&apos;, function () {

            var dataObj = querystring.parse(postData);
              // querystring.parse将POST参数解析成对象格式;需要引入模块;

            res.end(&apos;POST DATA SUCCESS!&apos;);
        });

    } else {
        res.end(&apos;404&apos;);
    }

});

server.listen(3000, &apos;127.0.0.1&apos;);
</code></pre><h3 id="文件上传处理"><a href="#文件上传处理" class="headerlink" title="文件上传处理"></a>文件上传处理</h3><pre><code>原生写POST处理,比较复杂,要写两个监听.
文件上传业务比较麻烦.所以,用第三方模块: `formidable`
先用NPM安装 npm install formidable --save
</code></pre><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>var http = require(&apos;http&apos;);
var fs = require(&apos;fs&apos;);
var querystring = require(&apos;querystring&apos;);
var formidable = require(&apos;formidable&apos;);
var datetime = require(&apos;silly-datetime&apos;);
var path = require(&apos;path&apos;);


var server = http.createServer(function (req, res) {
    if (req.url == &apos;/form&apos;) {
        fs.readFile(&apos;./form_file.html&apos;, function (err, data) {
            res.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html;charset=UTF-8&quot;});
            res.end(data);
        });
    } else if (req.url == &apos;/dopost&apos; &amp;&amp; req.method.toLowerCase() == &apos;post&apos;) {
        // 进行POST 文件数据处理
        var form = new formidable.IncomingForm();
        form.uploadDir = &quot;./uploads&quot;;

        // 该模块已经将 POST数据和文件数据 分离好了;fields是表单对象,files是文件对象;
        // 当执行到parse的回调时,表示表单的各种数据已经接收到了; 
        form.parse(req, function (err, fields, files) {

            res.writeHead(200, {&apos;content-type&apos;: &apos;text/html&apos;});

            // 文件改名
            // 生成新名字: 时间 + 随机数 + 源文件后缀: 2017012311223301236.jpg
            var t = datetime.format(new Date(), &apos;YYYYMMDDHHmmss&apos;);
            var ran = parseInt(Math.random() * 10000);
            var extname = path.extname(files.myfile.name);

            // 旧文件名
            var oldpath = &apos;./&apos; + files.myfile.path;
            // 新文件名
            // var newpath = &apos;./uploads/&apos; + t + ran + extname;
            var newpath = &apos;./uploads/111&apos; + extname;

            // 执行改名
            fs.rename(oldpath, newpath, function (err) {
                 if(err) console.log(&apos;改名失败&apos;);
                res.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html;charset=UTF-8&quot;});
                res.end(&apos;表单信息 处理完成111&apos;);
            });

        });

    } else {
        res.end(&apos;404&apos;);
    }
});


server.listen(3000, &apos;127.0.0.1&apos;);
</code></pre><h3 id="EJS模板使用"><a href="#EJS模板使用" class="headerlink" title="EJS模板使用"></a>EJS模板使用</h3><pre><code>http://www.embeddedjs.com/        #官网
https://www.npmjs.com/package/ejs #npm上的ejs包
ejs是Embedded JavaScript templates的简称,意思是嵌入式JavaScript模板.node中的后台模版.
1.安装ejs模块
     npm install ejs --save
2.引入ejs模块
    var ejs = require(&apos;ejs&apos;);
3.创建模版(必须是字串形式)
    var str = &apos;扎心了,老铁. 双击 &lt;%= num %&gt;&apos;;
4.准备数据(数组形式)
    var data = {
        num: 6666666
    }
5.数据绑定
    var html = ejs.render(str, data);

6.输出
    console.log(html);
</code></pre><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><pre><code>1.创建(EJS模板)
    先用HTML文档编辑好之后,把文件后缀改成ejs即可,变量设置方式参照上文;
2.模块部分
    var http = require(&apos;http&apos;);
    var fs = require(&apos;fs&apos;);
    var ejs = require(&apos;ejs&apos;);

    var server = http.createServer(function (req, res) {
        if (req.url == &apos;/&apos;) {
            fs.readFile(&apos;./views/index.ejs&apos;,function (err, data) {
                // 数据处理
                var template = data.toString();

                var dict = {
                    title  : &quot;EJS模版引擎的实用&quot;,
                    content : &quot;我就是个段落内容&quot;,
                    pic : &apos;./imgs/01.jpg&apos;,
                    songci : {
                        title : &apos;水调歌头&apos;,
                        list : [
                            &quot;明月几时有&quot;,
                            &quot;把酒问青天&quot;,
                            &quot;不知天上宫阙&quot;,
                            &quot;今夕是何年&quot;
                        ]
                    }
                }
                // 绑定数据
                var html = ejs.render(template, dict);

                // 输出
                res.writeHead(200, {&apos;content-type&apos;: &apos;text/html&apos;});
                res.end(html);
            });
        } else if (req.url == &apos;/imgs/01.jpg&apos;) {
            fs.readFile(&apos;./imgs/01.jpg&apos;,function (err, data) {
                // 输出
                res.writeHead(200, {&apos;content-type&apos;: &apos;image/jpeg&apos;});
                res.end(data);
            });
        } else {
            res.writeHead(404, {&apos;content-type&apos;: &apos;text/html&apos;});
            res.end(&apos;404&apos;);
        }
    });

    server.listen(3000, &apos;127.0.0.1&apos;);
</code></pre>]]></content>
      
        <categories>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js]]></title>
      <url>/2017/12/08/node.js/</url>
      <content type="html"><![CDATA[<h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一.安装"></a>一.安装</h2><pre><code>下载地址:http://nodejs.cn/
1.根据系统选择32位或64位安装包
2.windows推荐下载.msi的安装包
3.linux下载源码包(注意linux系统版本)
    可以通过命令file /sbin/init 或者 file /bin/ls查看linux的系统位数.
</code></pre><h4 id="linux-安装步骤"><a href="#linux-安装步骤" class="headerlink" title="linux 安装步骤"></a>linux 安装步骤</h4><pre><code>1.上传源码包到/node目录下
    mkdir node  
    将压缩包上传到该目录

2.解压到当前目录(此源码包不用编译)
    tar -xf node-v8.9.0-linux-x64.tar.xz

3.移动node目录到/usr/local
    mv node-v8.9.0-linux-x64.tar.xz /usr/local

4.进入node里的bin目录,并查看相关文件
    cd /usr/local/node/bin
    ls 
    里面有 node npm npx 这三个文件即可;

5.在bin目录下查看Node的版本
    ./node -v
    如果显示版本说明正常,否则源码包可能有问题.

6.设置环境变量
    vim ~/.bash_profile

    修改:PATH=SPATH:SHOME/bin:/usr/local/node/bin
    保存退出

7.重启服务
    source ~./bash_profile

8.在全局下查看node版本
    node -v
    npm -v
    出现版本说明环境变量设置成功
</code></pre><h4 id="windows安装步骤"><a href="#windows安装步骤" class="headerlink" title="windows安装步骤"></a>windows安装步骤</h4><pre><code>1.找到安装包
2.双击安装,一直下一步至结束.
3.安装完成后,用cmd或cmder查看版本
    node -v
    出现版本说明安装成功,环境变量自动生成.
</code></pre><h2 id="二-node-js的特点"><a href="#二-node-js的特点" class="headerlink" title="二.node.js的特点"></a>二.node.js的特点</h2><pre><code>1.它既是语言,又是平台.
2.单线程 | 非阻塞I/O | 事件驱动

    1). 单线程
        所有客户端请求的连接 都使用一个线程来处理.
        Node.js不是为每个连接创建一个新的线程,而是仅仅使用一个线程,来处理所有业务逻辑.
        单线程带来的好处,系统不在有线程的创建和销毁的额外开销.(内存换页)

    2). 非阻塞I/O
        I: 输入 input
        O: 输出 output
        I/O操作: 读写数据库/读写文件/执行运算/网络通讯
        I/O操作不会阻塞程序的运行

        在阻塞模式下,一个线程只能处理一项任务,想要提高吞吐率(并发量)必须通过多线程.
        而非阻塞模式下,一个线程 永远在执行运算操作,这个线程的利用率是满载的.


    3). 事件驱动
        客户端 请求建立连接，提交数据等行为，就会触发 相应的事件.
        在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行 一个事件回调函数的中途，
        可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制.

    Node.js底层是C++(V8引擎也是C++写的).底层代码中，近半数都用于事件队列、回调函数队列的构建.
    用事件驱动 来完成服务器的 任务调度,是Node.js中 真正底层核心逻辑.
</code></pre><h2 id="三-常用模块"><a href="#三-常用模块" class="headerlink" title="三.常用模块"></a>三.常用模块</h2><pre><code>简单理解:
    把Node.js当做一台空服务器,模块的作用就是在这台服务器上嵌入增加功能;
</code></pre><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><pre><code>1.引入http模块:
    var http = require(&apos;http&apos;);
2.主机名:
    var hostname = &apos;IP或者域名&apos;;
3.端口:
    var port = 1024 ~ 65535; (建议TCP端口范围)
4.创建服务器:
    var server = http.createServer(回调函数);
5.回调函数:
    function(req,res){}
6.回调传参:
    1) 请求对象(request)
        req        // 有请求时,自动接受该请求的相关参数;
    2) 响应对象(response)
        res        // 响应时的数据处理;

        常用:
            res.writeHead();设置HTTP响应头信息;
            res.end();        输出响应结果;
7.运行服务器:
    server.listen(port,hostname,回调函数);

实例:
    // 第一部分:模块加载
    var http = require(&apos;http&apos;);
    var hostname = &apos;127.0.0.1&apos;;
    var port = 3000;
        (代码运行顺序:1)    
    // 第二部分:服务器构造
    var server = http.createServer(function (req, res){
        res.writeHead(200, {&quot;Content-type&quot;:&quot;text/html;charset=utf-8&quot;});
        res.end(&apos;Hi~ o(*￣▽￣*)ブ, 首个Node.js页面. 您好,SVIP: 您的积分是: &apos;+ (50+10) + &apos;分!&apos;);
        (代码运行顺序:3)
    });

    // 第三部分:运行服务器
    server.listen(port, hostname, function (){
        console.log(`请访问: http://${hostname}:${port}/`);
    });
    (代码运行顺序:2)

分析:
    把Node.js的服务拆分成三个部分,比较容易理解;

    第一部分:
        模块加载,不管是系统自带的模块,还是自己写的模块.要想在这个系统中去使用,都必须要加载模块;

    第二部分:
        服务器构造,简单说就是服务器具体功能的实现,也是Node.js无阻塞I/O和事件环的根本所在.所有请求的入口就在这里;

    第三部分:        
        运行服务器,就相当于服务器的网关.从它的传参可以看出,主要是定义服务器的端口和IP或域名;
</code></pre><h4 id="事件驱动-事件环"><a href="#事件驱动-事件环" class="headerlink" title="事件驱动-事件环:"></a>事件驱动-事件环:</h4><pre><code>1.从代码运行顺序可以看出,并非是从上到下的顺序.因为默认情况下,它是异步的;
2.当程序执行时,模块加载完,服务器生成,开启服务器,有请求进来的时候,req接受到请求之后,res才会触发处理数据并返回,这个过程是需要耗时的;
3.可以通过迭代器等方式将代码执行方式变成同步;
</code></pre><h4 id="报文对象"><a href="#报文对象" class="headerlink" title="报文对象"></a>报文对象</h4><pre><code>1.请求头信息;
    req.headers            // 返回一个对象,包含请求的头信息数据;
2.请求方式;
    req.method            // 传输方式;
3.请求头列表;
    req.rawHeaders        // 返回一个数组,内容与headers一致;
4.状态码;
    res.statusCode        // 返回响应状态码
5.响应信息;
    res.statusMessage    // 返回状态描述
6.URL链接;
    req.url                // 返回url链接 (path ~ hash)
</code></pre><h3 id="URL模块"><a href="#URL模块" class="headerlink" title="URL模块"></a>URL模块</h3><pre><code>┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                                            href                                             │
├──────────┬──┬─────────────────────┬─────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │        host         │           path            │ hash  │
│          │  │                     ├──────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │   hostname   │ port │ pathname │     search     │       │
│          │  │                     │              │      │          ├─┬──────────────┤       │
│          │  │                     │              │      │          │ │    query     │       │
&quot;  https:   //    user   :   pass   @ sub.host.com : 8080   /p/a/t/h  ?  query=string   #hash &quot;
│          │  │          │          │   hostname   │ port │          │                │       │
│          │  │          │          ├──────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │        host         │          │                │       │
├──────────┴──┼──────────┴──────────┼─────────────────────┤          │                │       │
│   origin    │                     │       origin        │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴─────────────────────┴──────────┴────────────────┴───────┤
│                                            href                                             │
└─────────────────────────────────────────────────────────────────────────────────────────────┘

1.引入URL模块:
    var url = require(&apos;url&apos;);
2.解析URL:
    req.url // 请求的路径

    var path = url.parse(req.url).path;
    var pathname = url.parse(req.url).pathname;
    var search = url.parse(req.url).search;
    var query = url.parse(req.url).query;
    var hash = url.parse(req.url).hash;


3.处理get参数:
    var getParams = url.parse(req.url,true).query;

*注: url.pars() 为解析URL的信息,当第2参为true时,可以将query(get)参数解析成对象返回;
</code></pre><h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><pre><code>1.引入fs模块:
    var fs = require(&apos;fs&apos;);

2.创建文件夹
    fs.mkdir(&apos;目录路径&apos;, function(err){

    });

3.删除文件夹
    fs.rmdir(&apos;目录路径&apos;, function(err){

    });

4.读取文件或目录信息
    fs.stat(&apos;文件或目录路径&apos;, function (err, stats){

    });

    1) 回调参数
        stats 文件或目录的信息

    2) 函数
        stats.isFile()            // 是否是文件
        stats.isDirectory()     // 是否是目录

5.读取文件夹内容
    fs.readdir(&apos;目录路径&apos;, function(err, files){

    });

    1) 回调参数
        files        // 返回一个数组,包含该目录下所有文件;
</code></pre><h3 id="四-Node-js路由"><a href="#四-Node-js路由" class="headerlink" title="四. Node.js路由"></a>四. Node.js路由</h3><pre><code>简单理解就是控制URL的访问,是对页面请求的一种控制方式;
实例:
    var http = require(&apos;http&apos;);
    var url = require(&apos;url&apos;);
    var hostname = &apos;127.0.0.1&apos;;
    var port = 3000;

    var server = http.createServer(function(req,res){
        if (req.url == &apos;/favicon.ico&apos;)return;
        res.writeHead(200,{&quot;Content-type&quot;:&quot;text/html;charset=utf-8&quot;});

        var user = url.parse(req.url).pathname;

            if (user.substr(0,5) == &apos;/stu/&apos;) {
                var stuid = user.substr(5);
                if (/^\d{11}$/.test(stuid)) {
                    res.end(&apos;学员id&apos; + stuid);
                }else{
                    res.end(&apos;学员不存在&apos;);
                }
            }else if(user.substr(0,5) == &apos;/tch/&apos;){
                var tchid = user.substr(5);
                if (/^\d{5}$/.test(tchid)) {
                    res.end(&apos;员工id&apos; + tchid);
                }else{
                    res.end(&apos;员工不存在&apos;);
                }
            }else{
                res.end(&apos;URL有误!&apos;);
            }
    });

    // 运行服务器
    server.listen(port, hostname);    

分析:
    从if else就可以看出这是对流程控制的一种方式.所有的if条件都是在匹配,请求的参数是否正确;
</code></pre><h3 id="五-迭代器"><a href="#五-迭代器" class="headerlink" title="五. 迭代器"></a>五. 迭代器</h3><pre><code>在Node.js开发中,由于特性的原因,代码异步执行的情况很多.但基于环境不同,也不可能完全都用异步操作.而迭代器的作用就是强制将异步变为同步;

错误实例:
    目的:访问imgs这个文件夹,读取文件夹内容,将里面的子aaa bbb ccc 3个文件夹拿出来存入WJJ数组,然后显示出来;

    var server = http.createServer(function (req, res){
        if (req.url == &apos;/favicon.ico&apos;) return;

        fs.readdir(&apos;./imgs&apos;, function (err, files){
            // console.log(files);
            // [ &apos;1.jpg&apos;, ...&apos;9.jpg&apos;, &apos;aaa&apos;, &apos;bbb&apos; ]
            // 存储所有的文件夹
            var wjj = [];

            for (var i = 0; i &lt; files.length; i++) {
                var thisname = files[i]; // 文件或文件夹
                // 检测 是否是目录
                fs.stat(&apos;./imgs/&apos;+thisname, function(err, stats){
                    // 如果是文件夹 则将文件夹名字放入数组
                    if (stats.isDirectory()) {
                        wjj.push(thisname);
                    }
                    console.log(wjj);
                });
            }  //   END - for
        console.log(wjj, &apos;循环完成&apos;);
        });

        res.end(&apos;SUCCESSED!&apos;);
    });

    输出结果:
        [] &apos;循环完成&apos;
        []
        []
        []
        []
        []
        []
        []
        []
        []
        []
        [ &apos;ccc&apos; ]
        [ &apos;ccc&apos;, &apos;ccc&apos; ]
        [ &apos;ccc&apos;, &apos;ccc&apos;, &apos;ccc&apos; ]
    分析:
        1) 在创建服务器的时候,就使用了回调函数,这是第1个异步操作;
        2) 在读取文件夹的时候,又用了回调函数,这是第2个异步操作;
        3) 在for循环里,判断每一个文件是否是目录时,又用了回调函数,这是第3个异步操作;

        代码从最外层开始执行,第一个被打印的是for循环外的内容;然后打开文件夹没有问题,但for循环在执行的时候,速度是很快的.回调函数还没有来得及处理,for循环已经结束;
        所以最终返回的只有ccc,且因为有3个文件夹,所以放入数组3次,最终结果为3个CCC;

迭代器实例:
    fs.readdir(&apos;./imgs&apos;, function (err, files){
        var wjj = [];

        (function iterator(i){

            if (i == files.length) {
                console.log(wjj,&apos;结果&apos;);
                return;
            }

            fs.stat(&apos;./imgs/&apos;+ files[i], function (err, stats){
                if (stats.isDirectory()) {
                    wjj.push(files[i]);
                }
                console.log(wjj);
                iterator(i+1);
            });
        })(0);
    });
    输出结果:
        []
        []
        []
        []
        []
        []
        []
        []
        []
        [ &apos;aaa&apos; ]
        [ &apos;aaa&apos;, &apos;bbb&apos; ]
        [ &apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos; ]
        [ &apos;aaa&apos;, &apos;bbb&apos;, &apos;ccc&apos; ] &apos;结果&apos;

    分析:
        原理用自执行函数+递归,生成一个迭代器;(类似JS中的计数器用法)

        1) 判断部分代码没有变化,只是在最后自增递归,使得这段代码可以重复执行;
        2) files是一个数组,用数组的长度作为自执行里中断开关;


同步函数实例:
     for (var i = 0; i &lt; files.length; i++) {
        var thisname = files[i];
        var thisStat = fs.statSync(&apos;./imgs/&apos;+thisname);
        if (thisStat.isDirectory()) {
            wjj.push(thisname);
        }
    }

    fs.statSync(文件路径)  // 功能与stat一样,但是是同步执行的;
</code></pre><h3 id="六-输出变量-函数"><a href="#六-输出变量-函数" class="headerlink" title="六. 输出变量/函数"></a>六. 输出变量/函数</h3><pre><code>Node.js中,JS文件中定义的变量、函数,都只在这个文件内部有效. 
其他文件中需要引用变量、函数时,必须使用exports对象进行输出(暴露). 
使用者要用require()命令,引用执行这个JS文件.

实例:
    (fun1.js)
        var str = &apos;我是fun1里的str&apos;;
        var msg = &apos;我是fun1里的msg&apos;;

        function showMsg() {
            console.log(&apos;函数的结果是: &apos;+ msg);
        }

        exports.str = str;
        exports.showMsg = showMsg;

    (module.js)
        var fun1 = require(&apos;./module/fun1.js&apos;);

        console.log(fun1.str);

        fun1.showMsg();
</code></pre><h3 id="输出类-构造函数"><a href="#输出类-构造函数" class="headerlink" title="输出类(构造函数)"></a>输出类(构造函数)</h3><pre><code>可以用module.exports = 构造函数名;的方式 向外输出一个类

实例:
    (user.js)

        function user(name, age) {
            this.name = name;
            this.age = age;
            this.getInfo = function() {
                console.log(name + &apos;:&apos; + age);
            }
        }

        module.exports = user;

    (demo.js)
        var user = require(&apos;./module/user&apos;);

        var yy = new user(&apos;艳艳&apos;,&apos;18&apos;);

        console.log(yy.name);
        yy.getInfo();
</code></pre>]]></content>
      
        <categories>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Memcache分布式缓存系统]]></title>
      <url>/2017/12/08/memcached/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="Memcache简介"><a href="#Memcache简介" class="headerlink" title="Memcache简介"></a>Memcache简介</h2><p><strong>1.  缘起</strong></p>
<blockquote>
<p>在数据驱动的web开发中，经常要重复从数据库中取出相同的数据，<br>这种重复极大的增加了数据库负载。缓存是解决这个问题的好办法。<br>但是Web中的虽然已经可以实现对页面局部进行缓存，但还是不够灵活。<br>此时Memcached或许是你想要的。最新版本:1.4.36</p>
</blockquote>
<p>官网：<a href="http://memcached.org/" target="_blank" rel="noopener">http://memcached.org/</a></p>
<p><strong>2. Memcached是什么?</strong></p>
<blockquote>
<p>Memcached是由Danga Interactive开发的，高性能的，分布式的内存对象缓存系统，用于在动态应用中减少数据库负载，提升访问速度。</p>
</blockquote>
<p><strong>3. Memcached能缓存什么？</strong></p>
<blockquote>
<p>通过在内存里维护一个统一的巨大的hash表，Memcached能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。各种数据都是以字符串的方式存放的。</p>
</blockquote>
<p><strong>4. Memcached快么？</strong></p>
<blockquote>
<p>非常快。Memcached使用了libevent（如果可以的话，在linux下使用epoll）来均衡任何数量的打开链接，<br>使用非阻塞的网络I/O，对内部对象实现引用计数(因此，针对多样的客户端，对象可以处在多样的状态)，<br>使用自己的页块分配器和哈希表，因此虚拟内存不会产生碎片并且虚拟内存分配的时间复杂度可以保证为O(1)。<br>Danga Interactive为提升Danga Interactive的速度研发了Memcached。</p>
</blockquote>
<p><strong>5. Memcached的特点</strong></p>
<blockquote>
<p>Memcached的缓存是一种分布式的，可以让不同主机上的多个用户同时访问，<br>因此解决了共享内存只能单机应用的局限，更不会出现使用数据库做类似事情的时候，<br>磁盘开销和阻塞的发生。</p>
</blockquote>
<p>缓存数据:</p>
<ol>
<li>在内存中缓存数据</li>
<li>数据形态以key-&gt;value结构</li>
<li>安全性不佳，但有应对方法</li>
</ol>
<h2 id="Memcache安装"><a href="#Memcache安装" class="headerlink" title="Memcache安装"></a>Memcache安装</h2><p><strong>1. Windows安装操作</strong></p>
<p>1.1 在网上下载memcached-1.2.1-win32.zip。解压放某个盘下面，比如在D:\memcached</p>
<p>1.2 在终端（cmd）下：（管理员权限打开CMD!!!!!）</p>
<pre><code>D:\&gt;memcached.exe -d install     安装
D:\&gt;memcached.exe -d uninstall 卸载
D:\&gt;memcached.exe -d start     启动
D:\&gt;memcached.exe -d stop     停止
    memcached.exe -h  获取所有帮助
</code></pre><p>1.3 在启动之后连接：<br>    <code>D:\&gt;telnet 127.0.0.1 11211</code>   –连接memcache端口11211<br>    使用quit退出。</p>
<p>如果没有telnet工具请在“windows功能”中选择开启“telnet客户端”</p>
<p>1.4 其他命令参数：</p>
<pre><code>启动Memcache 常用参数
-p &lt;num&gt;   设置端口号(默认不设置为: 11211)
-U &lt;num&gt;   UDP监听端口(默认: 11211, 0 时关闭) 
-l &lt;ip_addr&gt; 绑定地址(默认:所有都允许,无论内外网或者本机更换IP，
    有安全隐患，若设置为127.0.0.1就只能本机访问)
-d   独立进程运行
... -d start 启动memcached服务 
... -d restart 重起memcached服务 
... -d stop|shutdown 关闭正在运行的memcached服务 
... -d install 安装memcached服务 
... -d uninstall 卸载memcached服务 
-u &lt;username&gt; 绑定使用指定用于运行进程&lt;username&gt;
-m &lt;num&gt;  允许最大内存用量，单位M (默认: 64 MB)
-P &lt;file&gt; 将PID写入文件&lt;file&gt;，可以使得后边进行快速进程终止, 需要与-d 一起使用
-M 内存耗尽时返回错误，而不是删除项 
-c 最大同时连接数，默认是1024 
-f 块大小增长因子，默认是1.25 
-n 最小分配空间，key+value+flags默认是48 
-h 显示帮助
</code></pre><p>1.5 windows的php扩展</p>
<pre><code>php扩展目录 extension_dir
php_memcache.dll放置到php扩展目录ext下

php配置文件修改
extension=php_memcache.dll,
重启服务
</code></pre><p><strong>2. Linux安装操作（根据当前环境等匹配安装各个包！）</strong></p>
<p>2.1 安装memcached的底层功能依赖包libevent</p>
<pre><code>tar -xf libevent-release-1.4.15-stable.tar.gz 
cd libevent-release-1.4.15-stable
./autogen.sh 
./configure  --prefix=/usr
make &amp;&amp; make install
</code></pre><p>2.2 安装memcached服务</p>
<pre><code>tar -xf memcached-1.4.36.tar.gz          解压memcached
cd memcached-1.4.36                    进入 memcached目录
./configure --prefix=/usr/local/memcached      配置
make &amp;&amp; make install                        编译与安装
useradd  memcache                            添加运行用户
修改该伪用户的登录权限为不能登录
vim /etc/passwd                        
memcache:x:501:501::/home/memcache:/sbin/nologin
</code></pre><p>2.3 运行memcached服务</p>
<pre><code>/usr/local/memcached/bin/memcached -u memcache &amp;
</code></pre><p>2.4 客户端访问（注意格式，错了重打）</p>
<pre><code>telnet 127.0.0.1 11211

stats
set
get
……
</code></pre><p>2.5 写入自启动和关闭进程</p>
<pre><code>vim /etc/rc.local
/usr/local/memcached/bin/memcached -u memcache &amp;
pkill memcached        
</code></pre><p>2.6 安装php_memcache扩展</p>
<pre><code>unzip pecl-memcache-php7.zip
cd  pecl-memcache-php7
/usr/local/php/bin/phpize
./configure  --with-php-config=/usr/local/php/bin/php-config
make  &amp;&amp;  make  install

修改 php.ini 后重启apache即可生效
vim /usr/local/php/etc/php.ini
查找extension=&quot;openssl.so&quot;;
下一行添加extension=&quot;memcache.so&quot;;
重启apache
/usr/local/apache2/bin/apachectl stop
/usr/local/apache2/bin/apachectl start
</code></pre><p>2.7 安装libmemcached（版本匹配不能超过php_memcached）</p>
<pre><code>tar -xf libmemcached-1.0.18.tar.gz
cd  libmemcached-1.0.18                    
./configure &amp;&amp; make &amp;&amp; make install
</code></pre><p>2.8 安装php_memcached扩展</p>
<pre><code>tar -xf memcached-3.0.3.tgz
cd memcached-3.0.3

修改文件
vim  php_libmemcached_compat.h 

/* this is the version(s) we support */
 21 #include &lt;/usr/local/include/libmemcached/memcached.h&gt;

修改结束

/usr/local/php/bin/phpize
./configure  --disable-memcached-sasl  --with-php-config=/usr/local/php/bin/php-config
make &amp;&amp; make install

修改 php.ini 后重启apache即可生效
vim /usr/local/php/etc/php.ini
查找extension=&quot;openssl.so&quot;;
下一行添加extension=&quot;memcached.so&quot;;
重启apache
/usr/local/apache2/bin/apachectl stop
/usr/local/apache2/bin/apachectl start
</code></pre><h2 id="Memcache客户端（Telnet）相关操作"><a href="#Memcache客户端（Telnet）相关操作" class="headerlink" title="Memcache客户端（Telnet）相关操作"></a>Memcache客户端（Telnet）相关操作</h2><p><strong>stats 查看状态</strong></p>
<pre><code>STAT pid 1552                      服务进程的进程ID
STAT uptime 3792                服务从启动到当前所经过的时间，单位是秒。
STAT time 1262517674              服务器所在主机当前系统的时间，单位是秒。
STAT version 1.2.6                   组件的版本。这里是我当前使用的1.2.6。
STAT pointer_size 32             服务器所在主机操作系统的指针大小，一般为32或64.
STAT curr_items 1                   表示存放当前的所有缓存对象的数量。不包括已经从缓存中删除的对象。
STAT total_items 2                   表示从启动到当前，系统存储过的所有对象数量，包括已经删除的对象。
STAT bytes 593                      表示系统存储缓存对象所使用的存储空间，单位为字节。
STAT curr_connections 2           表示当前系统打开的连接数。
STAT total_connections 28        表示从memcached服务启动到当前时间，系统打开过的连接的总数。
</code></pre><p><strong>set  写入缓存</strong></p>
<pre><code>set  键名  标记  有效时间  数据的长度

set  love  10     0           10
i love you
    键名
        最大不能超过250个字符
    标记
        是一个16位的无符号的整数，在客户端get数据时返回
    有效时间
        单位为秒
    数据长度
        单位是字节
    数据的值
        最大不能超过1024kb
</code></pre><p><strong>get  获取缓存</strong></p>
<pre><code>get  键名
get  love
</code></pre><p><strong>delete  删除缓存</strong></p>
<pre><code>delete   键名
delete   love
flush_all清空所有缓存
</code></pre><p><strong>其它常用命令</strong></p>
<pre><code>存储:
    set  add  replace    格式同set
获取:
    get     可一次获取多个
其它:
stats items 命令用于显示各个 slab 中 item 的数目和存储时长,配合使用可以查看所有 key
&gt; stats items // 这条是命令
     STAT items:7:number 1 
     STAT items:7:age 188
     END
&gt; stats cachedump 7 0 // 这条是命令
    ITEM Sess_sidsvpc1473t1np08qnkvhf6j2 [183 b; 1394527347 s]
    END
&gt; version 查看版本
</code></pre><h2 id="PHP操作Memcached服务"><a href="#PHP操作Memcached服务" class="headerlink" title="PHP操作Memcached服务"></a>PHP操作Memcached服务</h2><p><strong>PHP开启Memcache模块</strong></p>
<pre><code>phpinfo检测是否开启
</code></pre><p><strong>PHP Memcahe类</strong></p>
<pre><code>详见手册
</code></pre><p><strong>PHP Memcahed类</strong></p>
<pre><code>详见手册
添加后支持laravel
</code></pre><p><strong>Memcache存放Session</strong></p>
<blockquote>
<p>修改session配置，有几种方法</p>
</blockquote>
<pre><code>1、如果你能修改到服务器配置文件，那就打开打开php.ini
修改下面两项：
    session.save_handler = memcache
    session.save_path = &quot;tcp://127.0.0.1:11211&quot;
2、修改网站根目录下的.htaccess文件
    php_value session.save_handler &quot;memcache&quot;
    php_value session.save_path  &quot;tcp://127.0.0.1:11211&quot;
3、最常用的方法  在程序代码中修改（推荐）
       ini_set(&quot;session.save_handler&quot;, &quot;memcache&quot;);
       ini_set(&quot;session.save_path&quot;, &quot;tcp://127.0.0.1:11211&quot;);
</code></pre><blockquote>
<p>注：使用多个 memcached server 时用逗号”,”隔开，并且和 Memcache::addServer() 文档中说明的一样，可以带额外的参数”persistent”、”weight”、”timeout”、”retry_interval” 等等，类似这样的：</p>
</blockquote>
<p>“tcp://host:port?persistent=1&amp;weight=2,tcp://host2:port2”</p>
<blockquote>
<p>Memcache和MySQL配合存储Session</p>
</blockquote>
<pre><code>1、当用户登录时，将Session “set”到memcached，并写入数据库；
2、在Session中增加一个字段，标识Session最后写入数据库的时间；
3、每个页面加载的时候，优先从memcached读取Session，没有则从数据库读取；
4、每加载N页或者Y分钟后，再次将Session写入数据库；
</code></pre><h2 id="Memcache缓存机制"><a href="#Memcache缓存机制" class="headerlink" title="Memcache缓存机制"></a>Memcache缓存机制</h2><p><strong>Memcache在网站架构中的位置</strong></p>
<p><img src="http://i.imgur.com/WxREKm1.png" alt=""></p>
<p><strong>Memcache与MySQL的配合</strong></p>
<p><img src="http://i.imgur.com/V5thmMG.jpg" alt=""></p>
<p><strong>Memcache在脚本中的查询流程</strong></p>
<blockquote>
<p>1、先根据数据需求（SQL）取缓存，如果有返回数据，没有则根据需求查数据库</p>
<p>2、在数据库中查出的数据，并存入缓存。</p>
</blockquote>
<p><img src="http://i.imgur.com/TM8Vn47.jpg" alt=""></p>
<h2 id="Memcache的安全"><a href="#Memcache的安全" class="headerlink" title="Memcache的安全"></a>Memcache的安全</h2><blockquote>
<p>我们上面的Memcache服务器端都是直接通过客户端连接后直接操作，没有任何的验证过程，<br>这样如果服务器是直接暴露在互联网上的话是比较危险，轻则数据泄露被其他无关人员查看，<br>重则服务器被入侵，因为Mecache是以root权限运行的，<br>况且里面可能存在一些我们未知的bug或者是缓冲区溢出的情况，这些都是我们未知的，<br>所以危险性是可以预见的。</p>
<p>为了安全起见，我做两点建议，能够稍微的防止黑客的入侵或者数据的泄露。</p>
</blockquote>
<p><strong>内网访问</strong></p>
<blockquote>
<p>最好把两台服务器之间的访问是内网形态的，一般是Web服务器跟Memcache服务器之间。<br>普遍的服务器都是有两块网卡，一块指向互联网，一块指向内网，<br>那么就让Web服务器通过内网的网卡来访问Memcache服务器，<br>我们Memcache的服务器上启动的时候就监听内网的IP地址和端口，<br>内网间的访问能够有效阻止其他非法的访问。</p>
</blockquote>
<p><strong>设置防火墙</strong></p>
<blockquote>
<p>防火墙是简单有效的方式，如果却是两台服务器都是挂在网的，<br>并且需要通过外网IP来访问Memcache的话，<br>那么可以考虑使用防火墙或者代理程序来过滤非法访问。<br>一般我们在Linux下可以使用iptables或者FreeBSD下的ipfw来指定一些规则防止一些非法的访问，<br>比如我们可以设置只允许我们的Web服务器来访问我们Memcache服务器，同时阻止其他的访问。</p>
</blockquote>
<pre><code>iptables -A INPUT -p tcp -s 192.168.0.2 –dport 11211 -j ACCEPT
iptables -A INPUT -p udp -s 192.168.0.2 –dport 11211 -j ACCEPT
</code></pre><h2 id="《缓存二三事》"><a href="#《缓存二三事》" class="headerlink" title="《缓存二三事》"></a>《缓存二三事》</h2><blockquote>
<p>缓存和数据库，更新缓存和淘汰缓存</p>
</blockquote>
<pre><code>set/replace                        delete set/add
在数据较少修改时可用                数据量大且需要逻辑运算
</code></pre><p><img src="http://i.imgur.com/ap8Fsva.jpg" alt="">    <img src="http://i.imgur.com/jGPkild.jpg" alt=""></p>
<p><strong>先操作谁？</strong></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=404087915&amp;idx=1&amp;sn=075664193f334874a3fc87fd4f712ebc" target="_blank" rel="noopener">原文传送门</a></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>《Memcache 内存分配策略和性能(使用)状态检查》</p>
<p><a href="http://www.kuqin.com/shuoit/20160615/352392.html" target="_blank" rel="noopener">http://www.kuqin.com/shuoit/20160615/352392.html</a></p>
<p>《如果Memcache集群中的服务器失效如何踢出》</p>
<p><a href="http://www.tuicool.com/articles/qaAnUz" target="_blank" rel="noopener">http://www.tuicool.com/articles/qaAnUz</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql入门]]></title>
      <url>/2017/12/08/mysql(1)/</url>
      <content type="html"><![CDATA[<h2 id="Mysql基本讲解"><a href="#Mysql基本讲解" class="headerlink" title="Mysql基本讲解"></a>Mysql基本讲解</h2><pre><code>数据库:存数据
定义:存储数据的仓库

数据库:database
数据表:table

按照数据结构来组织,存储和管理数据的仓库

常见数据库系统
Oracle
MySQL
SQL Server 微软

登录数据库的必备条件
1.服务器环境开启   wamp
2.服务器IP地址       本地localhost
3.用户名:root
4.密码:空

数据库每条命令都已 分号 作为结束符

``:反引号  为了屏蔽关键字
将关键字取消特殊意义(库名,表名,字段名)
</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><pre><code>1.设置密码
    set password = password(&apos;密码&apos;)

2.创建一个数据库
    create database `库名`
    create database if not exists `库名`    推荐用

3.查看所有数据库
    show databases

4.查看当前所在的库
    select database()

5.删除一个数据库
    drop database `库名`

6.使用数据库
    use `库名`

7.查看所有的表
    show tables

8.查看当前使用的表
    desc `表名`

9.创建数据表
    create table if not exists `表名`(
        `表头名`   类型  属性,
        `表头名`   类型  属性,
        `表头名`   类型  属性,
        ...(最后一个字段 不要加 逗号)
    )engine=MyISAM(引擎) default charset=utf8

10.删除数据表
    drop table `表名`
</code></pre><p>字段属性</p>
<pre><code>1. 主键索引
    primary key
    一般一张表只有一个主键

2.自增
    auto_increment
    最小是1,通常配合主键

3.无符号
    unsigned : 没有负数

4.默认值
    default 默认值

5.非空约束
    not null : 不能为空

6.唯一索引
    unique

7.描述
    comment
</code></pre><p>新增数据<br>    插入单条数据:<br>    insert into <code>表名</code> values(包含所有表头元素的值);</p>
<pre><code>插入多条数据:
insert into `表名` values(包含所有表头元素的值),
(),(),.....;

插入单条指定内容的数据:
insert into `表名` (`表头名1`,`表头名2`,....)values(&quot;值1&quot;,&quot;值2&quot;,...);

插入多条指定内容的数据
insert into `表名` (`表头名1`,`表头名2`,...)
values
(&quot;值1&quot;,&quot;值2&quot;,...),
(&quot;值1&quot;,&quot;值2&quot;,...),
(&quot;值1&quot;,&quot;值2&quot;,...),
.....;
</code></pre><p>数据更新<br>    全表修改:<br>    update <code>表名</code> set <code>表头名</code>=”值”,<code>表头名</code>=”值”, …;</p>
<pre><code>指定修改:
update `表名` set `表头名`=&quot;值&quot;, ...
where 条件表达式 and (多条件时用)
</code></pre><p>删除数据<br>    全表删除<br>    delete from <code>表名</code>;</p>
<pre><code>指定删除
delete from `表名` where 条件表达式 and (多条件时用)
</code></pre><p>查询数据<br>    查询全表<br>    select * from user;</p>
<pre><code>根据表头查询(返回表头下所有数据)
select `表头名1`,`表头名2`, ...
from `表名`;

指定条件查询
select `表头名1`,`表头名2`, ...
from `user`
where 条件表达式 and (多条件时用)

排序查询 asc 升序 | desc 降序
select `主键或自增属性的表头`,`表头名2`, ...
from `表名`
where 条件表达式 (根据需求)
order by `主键或自增属性的表头` asc;

分组查询
select `表头名1`,`表头名2`, ...
from `表名`
where 条件表达式 (根据需求)
group by `表头名`
order by (根据需求,但排序必须是在分组之后执行)

分组后的条件筛选
select `表头名1`,`表头名2`, ...
from `表名`
where 条件表达式 (根据需求)
group by `表头名`
having 数据库函数的条件表达式

多表查询
select 表名1.表头名1,表头名2, ...
from `表名1`,`表名2`,...
where 表与表之间的关系
group by (根据需求)
order by (根据需求)

模糊查询
select `表头名1`,`表头名2`, ...
from `user`
where `表头名` like &quot;%值%&quot;;

表头内容下,含有like所定义的值的字符.
%值  = 以该值结尾的字符
值% = 以该值开头的字符
_ 代表单个字符

分页
limit rows 指定行数
limit key, rows 指定下标,指定行数

select * from `表名` limit 2;
select * from `表名` limit 0,2;

公式:key = (页数 - 1) * 指定行数
</code></pre><p>数据库函数</p>
<pre><code>聚合函数
count()     计数
sum()       求和
avg()       平均数
max()       最大
min()       最小

字符串函数
concat()    拼接字符串

数据库版本
select version();

当前时间    格式化时间
select now();

当前时间    时间戳
select UNIX_TIMESTAPM();
</code></pre>]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP-redis操作]]></title>
      <url>/2017/12/08/php-redis%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="php-redis操作"><a href="#php-redis操作" class="headerlink" title="php-redis操作"></a>php-redis操作</h2><pre><code>1.连接redis,成功返回true;
&lt;?php
    $redis = new redis();
    $result = $redis-&gt;connect(&apos;服务器IP&apos;, 6379);
    $redis-&gt;auth(&apos;密码&apos;);    //如果设置了密码，添加此行;
    var_dump($result);
&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[test]]></title>
      <url>/2017/12/08/test/</url>
      <content type="html"><![CDATA[<h1 id="测试博客主题"><a href="#测试博客主题" class="headerlink" title="测试博客主题"></a>测试博客主题</h1><p>##时间轴</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubantu-lamp环境搭建]]></title>
      <url>/2017/12/08/ubantu-lamp/</url>
      <content type="html"><![CDATA[<h2 id="ubantu-lamp环境搭建"><a href="#ubantu-lamp环境搭建" class="headerlink" title="ubantu lamp环境搭建"></a>ubantu lamp环境搭建</h2><pre><code>1.更新apt-get源
    sudo apt-get update

2.安装apache
    sudo apt-get install apache2

3.安装Mysql (有提示输入mysql的初始密码 默认用户为root)
    sudo apt-get install mysql-server mysql-client

4.安装php
    sudo apt-get install php7.0

5.安装php apache模块
    sudo apt-get install libapache2-mod-php

6. 安装php常用插件
    sudo apt-get install php7.0-mysql php7.0-mysql php7.0-curl php7.0-gd php7.0-mbstring php7.0-mcrypt php7.0-xml php7.0-zip

7.设置服务器域名解析和端口访问等
略...

8.#配置虚拟主机(可选)
修改文件
    vi /etc/apache2/sites-avilabe/000-default.conf
代码如下：
    &lt;VirtualHost *:80&gt;

    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/html/laravel/public (tp5框架文件目录)
    ServerName www.shxdledu.cn    (域名)

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

    &lt;/VirtualHost&gt;

9.配置成功后重启apahce 
    sudo service apache2 restart
</code></pre><h2 id="ubuntu-PHP安装redis扩展"><a href="#ubuntu-PHP安装redis扩展" class="headerlink" title="ubuntu-PHP安装redis扩展"></a>ubuntu-PHP安装redis扩展</h2><pre><code>cd /root    切换到root目录下

1.安装git(如果有git则跳过)
    sudo apt-get install git

2.下载phpredis
    git clone https://github.com/phpredis/phpredis.git

3.剪切到etc
    mv phpredis/ /etc/

4.切换目录
    cd /etc/phpredis

5.安装php7.0-dev (如果有则跳过)
    sudo apt-get install php7.0-dev

6.执行解析
    phpize

7.执行configure
    ./configure

8.编译和编译安装
    make &amp;&amp; make install

9.修改php配置文件(需要在conf.d下创建redis.ini文件)
    vi /etc/php/7.0/fpm/conf.d/redis.ini
    写入（extension=/etc/phpredis/modules/redis.so）

10.修改apache配置文件
    vi /etc/php/7.0/apache2/php.ini
    写入 （extension=/etc/phpredis/modules/redis.so）
    插入位置可以找 extension=mysql.dll

11.重启apache
    sudo service apache2 restart
</code></pre><h3 id="注意-当安装完lamp和redis之后-访问index-php可以找到redis模块已在php中被安装"><a href="#注意-当安装完lamp和redis之后-访问index-php可以找到redis模块已在php中被安装" class="headerlink" title="*注意:当安装完lamp和redis之后,访问index.php可以找到redis模块已在php中被安装."></a>*注意:当安装完lamp和redis之后,访问index.php可以找到redis模块已在php中被安装.</h3><h2 id="ubuntu-安装redis"><a href="#ubuntu-安装redis" class="headerlink" title="ubuntu-安装redis"></a>ubuntu-安装redis</h2><pre><code>1.安装redis
    sudo apt-get install redis-server

2.启动redis(出现欢迎界面)
    redis-server

3.进入控制台
    redis-cli

4.修改redis访问密码
    vi /etc/redis/redis.conf
    搜索 requirepass foobared
    取消注释并修改成 requirepass 密码
</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>安装 下载工具 wget
    sudo apt-get install -y wget

查看 wget版本        
    wget -version


安装composer        
    去composer 找命令

    建议切换到 /usr/local/bin

    使用wget安装composer wget 加上composer的官网下载地址

    wget https://getcomposer.org/download/1.4.1/composer.phar

    重命名文件composer.phar 为 composer 
    $ mv composer.phar composer

    $ chmod +x composer     

    然后如果需要git 他自带有的

    其实linux 和Windows 差别不大的，都是系统，我们用的也就是装软件而已。

    常用的目录结构
    WWW var/html
</code></pre>]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
